#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  from matplotlib.ticker import MaxNLocator
  from matplotlib.ticker import ScalarFormatter
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  from plotting import *
  import importlib
  import os
  import seaborn as sns
  from scipy.ndimage import uniform_filter1d
  j = 2
  plt.rcParams.update({"font.size": 20,
                       "figure.facecolor": "white",
                       "figure.figsize": (6,6),
                       #'font.family': 'serif',
                       #"font.serif": ["DejaVu Serif"],
                       #"text.usetex": False,
                       "axes.linewidth": 3,
                       'font.family': 'lmodern',
                       'text.usetex': True,
                       'text.latex.preamble': (            # LaTeX preamble
                           r'\usepackage{lmodern}'
                           # ... more packages if needed
                       )
                       })
  # Create an array with the colors you want to use
  #colors = ["#FF0B04", "#4374B3"]# Set your custom color palette
  #sns.set_palette("dark")
  
  pal = sns.color_palette("colorblind").as_hex()
  blue = pal[0]
  orange = pal[3]
  palette = [blue, orange, *pal[1:2], *pal[4:]]
  print(palette)
  sns.set_palette(sns.color_palette(palette))
  
  # important constants
  deg_conv = 180./np.pi
#+END_SRC

#+RESULTS:
: ['#0173b2', '#d55e00', '#de8f05', '#cc78bc', '#ca9161', '#fbafe4', '#949494', '#ece133', '#56b4e9']

* standard picture h=0.03
** preamble
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  class solve_eqeccs:
      def __init__(self, q, totmass, j, e1d, e2d, Tm1, Tm2, Te1, Te2, secterms=True):
          self.q = q
          self.mu2 = totmass/(1+q)
          alpha_0 = (j/(j+1))**(2./3.)
          self.alpha_0 = alpha_0
          self.alpha_2 = 1./alpha_0
          self.f1 = -A(alpha_0, j)
          self.f2 = -B(alpha_0, j)
          if secterms:
              self.C = C(alpha_0)
              self.D = D(alpha_0)
          else:
              self.C = 0.
              self.D = 0.
          self.e1d = e1d
          self.e2d = e2d
          self.Tm1 = Tm1
          self.Tm2 = Tm2
          self.Te1 = Te1
          self.Te2 = Te2
  
      def dote1(self, e1, e2, theta1, theta2):
          e1d = self.e1d
          deriv = -self.mu2/self.alpha_2*(self.f1*sin(theta1) + self.D*e2*sin(theta1-theta2)) - (e1-e1d)/self.Te1
          return(deriv)
      def dote2(self, e1, e2, theta1, theta2):
          e2d = self.e2d
          deriv = -self.mu2/self.alpha_2*self.q*(self.f2*sin(theta2) + self.D*e1*sin(theta2-theta1)) - (e2-e2d)/self.Te2
          return(deriv)
      def dotdpom(self, e1, e2, theta1, theta2):
          #deriv = self.mu2/self.alpha_2*(self.f1*cos(theta1)/(e1*sqrt(self.alpha_0))
          #         - self.q*cos(theta2)/e2
          #         + 2*self.C/sqrt(self.alpha_0)
          #         + self.D*e2/e1/sqrt(self.alpha_0)
          #         -self.q*2*self.C/sqrt(self.alpha_2)
          #         - self.q*self.D*e1/e2/sqrt(self.alpha_2))
          deriv = (self.f1*e2*cos(theta1)/(sqrt(self.alpha_0))
                   - self.q*self.f2*cos(theta2)*e1
                   + 2*self.C/sqrt(self.alpha_0)*e1*e2
                   + self.D*e2**2/sqrt(self.alpha_0)
                   -self.q*2*self.C/sqrt(self.alpha_2)*e1*e2
                   - self.q*self.D*e1**2/sqrt(self.alpha_2))
          return(deriv)
      def doteta(self, e1, e2, theta1, theta2):
          e1d = self.e1d
          e2d = self.e2d
          deriv = (self.q*sqrt(self.alpha_0)/(j*(self.q/self.alpha_0 + 1))
                   ,*(1./self.Tm2 - 1./self.Tm1
                     + 2*(e1)**2/self.Te1 - 2*(e2)**2/self.Te2)
                   - self.q*sqrt(self.alpha_0)*2*(e1-e1d)*e1/self.Te1
                   - 2*(e2-e2d)*e2/self.Te2)
          return(deriv)
      def __call__(self, vec):
          (e1, e2, theta1, theta2) = vec[:]
          e1_deriv = self.dote1(e1, e2, theta1, theta2)
          e2_deriv = self.dote2(e1, e2, theta1, theta2)
          dpom_deriv = self.dotdpom(e1, e2, theta1, theta2)
          eta_deriv =  self.doteta(e1, e2, theta1, theta2)
          deriv_arr = np.array([e1_deriv,
                                e2_deriv,
                                dpom_deriv,
                                eta_deriv])
          #print(vec, deriv_arr)
          return(deriv_arr)
  
  def calc_eeqs(h, qs, totmass, j, e1d, e2d, Tm1s, Tm2s, Te1s, Te2s, secterms=True):
      Nqs = len(qs)
      e1s = np.zeros(Nqs)
      e2s = np.zeros(Nqs)
      theta1s = np.zeros(Nqs)
      theta2s = np.zeros(Nqs)
  
      for iq, q in enumerate(qs):
          Te1 = 2*pi*Te1s[iq]
          Te2 = 2*pi*Te2s[iq]
          Tm1 = 2*pi*Tm1s[iq]
          Tm2 = 2*pi*Tm2s[iq]
          #if q <= 1:
          #    Te2d = TW0*2*np.pi
          #    Te1d = Te2d/q/alpha_0**0.5
  
          #    Tm1 = Te1d/2.7/h**2
          #    Tm2 = Te2d/2.7/h**2
          #else:
          #    Te1d = TW0*2*np.pi
          #    Te2d = Te1d*q*alpha_0**0.5
  
          #    Tm1 = Te2d/2.7/h**2
          #    Tm2 = Te1d/2.7/h**2
  
          if q > 1.:
              x0 = (0.01, 0.03, pi, 0.)
          else:
              x0 = (0.05, 0.03, pi, 0.)
          mfunc = solve_eqeccs(q, totmass, j, e1d, e2d, Tm1, Tm2, Te1, Te2, secterms=secterms)
          sol = scipy.optimize.root(mfunc, x0, options={"diag":np.ones(4)*totmass, "maxfev":int(5e6)})
          x = sol.x
          e1 = x[0]
          e2 = x[1]
          theta1 = x[2]
          theta2 = x[3]
          if not sol.success:
              print(sol.message)
              e1 = -1
              e2 = -1
          e1s[iq] = e1
          e2s[iq] = e2
          theta1s[iq] = theta1
          theta2s[iq] = theta2
          #print(x, mesg, infodict["nfev"])
          #print(theta1-theta2)
      return(e1s, e2s, theta1s, theta2s)
  
  os.chdir("/home/jtlaune/multi-planet-architecture/notes/")
#+END_SRC

#+RESULTS:

** get results
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  readme = "totmass q Te1 Te2 e1 e2 |g1-g2| \n " \
           "averages taken from 0.9xT; T = 20.xTe0; Te0=1000"
  H_SECTION = 0.03
  #################
  # CONFIGURATION #
  #################
  j = 2
  a0 = 1.0
  alpha_0 = (j/(j+1))**(2./3.)
  Nqs = 10
  qs = np.logspace(np.log10(0.5),np.log10(0.85),int(Nqs/2))
  qs = np.append(qs, np.logspace(np.log10(1.15),np.log10(2.0),int(Nqs/2)))
  print(qs)
  Nqs = len(qs)
  overwrite = True
  totmass = 1e-3
  e0 = 0.001
  
  ######################
  # Varying parameters #
  ######################
  Tw0 = 1000.
  TeRatios = np.sqrt(qs)
  
  ####################
  # THREADING ARRAYS #
  ####################
  TE_FUNCS = np.zeros(Nqs)
  G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  HS = np.ones(Nqs)*H_SECTION
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = np.array(qs)
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  ALPHA_0 = alpha_0*np.ones(Nqs)
  TE1 = Tw0/TeRatios
  TE2 = Tw0*TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TS = 25.*np.maximum(TE1, TE2)
  print(TS)
  #E1_0 = np.minimum(0.1/sqrt(QS), 0.1*np.ones(Nqs))
  #E2_0 = np.minimum(0.1*sqrt(QS), 0.1*np.ones(Nqs))
  E1_0 = np.ones(Nqs)*e0
  E2_0 = np.ones(Nqs)*e0
  print(E1_0,E2_0)
  E1DS = np.zeros(Nqs)
  E2DS = np.zeros(Nqs)
  CUTOFFS = TS
  #ALPHA2_0 = (3/2.)**(2./3)*(1+E2_0**2+E1_0**2)
  ALPHA2_0 = (1.7)**(2./3)*np.ones(Nqs)
  
  NAMES = np.array([f"q{QS[i]:0.2f}" for i in range(Nqs)])
  
  DIRNAMES = np.array([f"standard-h-{HS[i]:0.2f}-Tw0-{int(Tw0)}"
                       for i in range(len(QS))])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"-nosec" for i in range(Nqs)])
  ################
  # WITH SECULAR #
  ################
  results_arr = np.zeros((Nqs, 10))
  results_arr[:,0] = totmass
  results_arr[:,1] = QS
  results_arr[:,2] = TE1
  results_arr[:,3] = TE2
  for i, name in enumerate(NAMES):
      data = np.load(os.path.join(DIRNAMES[i], name+".npz"))
      teval  = data["teval"]
      theta  = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]
  
      it = int(len(teval)*0.9)
  
      results_arr[i,4] = np.average(e1[it:])
      results_arr[i,5] = np.average(e2[it:])
      results_arr[i,6] = np.average(np.abs(g1[it:]-g2[it:]))
      results_arr[i,7] = np.std(e1[it:])
      results_arr[i,8] = np.std(e2[it:])
      results_arr[i,9] = np.std(np.abs(g1[it:]-g2[it:]))
  np.savetxt(f"standard-h-{HS[0]}-Tw0-{int(Tw0)}.txt", results_arr, header=readme)
  
  ###################
  # WITHOUT SECULAR #
  ###################
  results_arr = np.zeros((Nqs, 10))
  results_arr[:,0] = totmass
  results_arr[:,1] = QS
  results_arr[:,2] = TE1
  results_arr[:,3] = TE2
  for i, name in enumerate(NAMES):
      data = np.load(os.path.join(DIRNAMES_NOSEC[i], name+".npz"))
      teval  = data["teval"]
      theta  = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]
  
      it = int(len(teval)*0.9)
  
      results_arr[i,4] = np.average(e1[it:])
      results_arr[i,5] = np.average(e2[it:])
      results_arr[i,6] = np.average(np.abs(g1[it:]-g2[it:]))
      results_arr[i,7] = np.std(e1[it:])
      results_arr[i,8] = np.std(e2[it:])
      results_arr[i,9] = np.std(np.abs(g1[it:]-g2[it:]))
  
  np.savetxt(f"standard-h-{HS[0]}-Tw0-{int(Tw0)}-nosec.txt", results_arr, header=readme)
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
#+END_SRC

#+RESULTS:
: [0.5        0.57092917 0.65192024 0.74440057 0.85       1.15
:  1.32062915 1.51657509 1.74159415 2.        ]
: [35355.33905933 33086.35242007 30962.98170492 28975.88177407
:  27116.30722733 26809.51323691 28729.65747832 30787.3258096
:  32992.36794667 35355.33905933]
: [0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001] [0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001]

** eeq eccentricities
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  fig, ax = plt.subplots(figsize=(6,6))
  fontsize=24
  h = HS[0]
  results = np.loadtxt(f"standard-h-{h}-Tw0-{int(Tw0)}.txt")
  Te1 = results[:,2]
  Te2 = results[:,3]
  ratio = Te1/Te2
  e1avg = results[:,4]
  e2avg = results[:,5]
  Dpomega = results[:,6]
  e1avg_std = results[:,7]
  e2avg_std = results[:,8]
  Dpomega_std = results[:,9]
  ax.errorbar(QS, e1avg, yerr=e1avg_std, fmt="o", c="k", label=r"$e_1$", capsize=2)
  ax.errorbar(QS, e2avg, yerr=e2avg_std, fmt="o", c="r", label=r"$e_2$", capsize=2)
  ax.tick_params(which="both", labelsize=fontsize, width=3, length=6,
                 bottom=True, top=True, left=True, right=True,
                 direction="in", pad=10)
  #ax.set_title(r"$q = $"+f"{q:0.1f}", fontsize=fontsize)
  
  # there is only negligible difference
  #results = np.loadtxt(f"standard-h-{h}-Tw0-{int(Tw0)}-nosec.txt")
  #Te1 = results[:,2]
  #Te2 = results[:,3]
  #ratio = Te1/Te2
  #e1avg = results[:,4]
  #e2avg = results[:,5]
  #Dpomega = results[:,6]
  #e1avg_std = results[:,7]
  #e2avg_std = results[:,8]
  #Dpomega_std = results[:,9]
  #ax.errorbar(ratio, e1avg, yerr=e1avg_std, fmt="o", c="k", label=r"w/o sec.", capsize=2)
  #ax.errorbar(ratio, e2avg, yerr=e2avg_std, fmt="o", c="r", label=r"w/o sec.", capsize=2)
  
  ax.set_ylabel(r"$e$", fontsize=36)
  ax.set_xlabel(r"$q$", fontsize=36)
  ax.set_xscale("log")
  #ax.set_xlim((0.45,2.05))
  #ax.set_ylim((0.0, 0.045))
  
  ylab = ax.get_yticklabels()
  ylab[0].set_visible(False)
  
  ax.legend(ncol=2, loc="best", fontsize=22)
  print(-TM2)
  
  qplot = np.linspace(0.5,2.0,100)
  TeRatiosplot = np.sqrt(qplot)
  Te1plot = Tw0/TeRatiosplot
  Te2plot = Tw0*TeRatiosplot
  Tm1plot = Te1plot/3.46/h**2*(-1*(qplot<1) + 1*(qplot>=1))
  Tm2plot = Te2plot/3.46/h**2*(-1*(qplot<1) + 1*(qplot>=1))
  e1s, e2s, theta1s, theta2s = calc_eeqs(h, qplot, totmass, j, 0., 0.,
                                         -Tm1plot, -Tm2plot, Te1plot, Te2plot, secterms=True)
  ax.plot(qplot, e1s, ls="--", c="k"  , label=(r"$e_1$"))
  ax.plot(qplot, e2s, ls="--", c="r", label=(r"$e_2$"))
  
  #e1s, e2s, theta1s, theta2s = calc_eeqs(HS[0], QS, totmass, j, 0., 0., -TM1, -TM2, TE1, TE2, secterms=False)
  ##print(e2s)
  #ax.plot(QS, e1s, ls="--", c="k"  ,   label=(r"$e_1$, w/o sec"))
  #ax.plot(QS, e2s, ls="--", c="r", label=(r"$e_2$, w/o sec"))
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  print(f"standard-eeqs-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}.png")
  fig.savefig(f"standard-eeqs-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}.png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: [ 227073.46858913  242645.64952394  259285.73513547  277066.95989251
:   296067.58051679 -344373.96579202 -369038.63170608 -395469.82414386
:  -423794.06482555 -454146.93717826]
: standard-eeqs-Tm2--454146-Tw0-1000.png
[[file:./.ob-jupyter/eac2a2640c260d5203f26724802eb80378edd3d8.png]]
:END:

** eq theta
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  fig, ax = plt.subplots(figsize=(6,6))
  fontsize=24
  results = np.loadtxt(f"standard-h-{h}-Tw0-{int(Tw0)}.txt")
  Te1 = results[:,2]
  Te2 = results[:,3]
  ratio = Te1/Te2
  e1avg = results[:,4]
  e2avg = results[:,5]
  Dpomega = results[:,6]*deg_conv
  e1avg_std = results[:,7]
  e2avg_std = results[:,8]
  Dpomega_std = results[:,9]*deg_conv
  ax.tick_params(which="both", labelsize=fontsize, width=3, length=6,
                 bottom=True, top=True, left=True, right=True,
                 direction="in", pad=10)
  ax.errorbar(QS, Dpomega, c="k", yerr=Dpomega_std, fmt="o", capsize=2)
  ax.tick_params(which="both", labelsize=fontsize)
  #ax.set_ylim((0., 0.05))
  #ax.set_title(r"$q = $"+f"{q:0.1f}", fontsize=fontsize)
  
  #results = np.loadtxt(f"standard-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}-nosec.txt")
  #Te1 = results[:,2]
  #Te2 = results[:,3]
  #ratio = Te1/Te2
  #e1avg = results[:,4]
  #e2avg = results[:,5]
  #Dpomega = results[:,6]*deg_conv
  #e1avg_std = results[:,7]
  #e2avg_std = results[:,8]
  #Dpomega_std = results[:,9]*deg_conv
  #ax.errorbar(QS, Dpomega, marker="x", c="gray", label=r"w/o sec.", yerr=Dpomega_std, fmt="o", capsize=2)
  
  ax.set_ylabel(r"$\Delta\varpi$", fontsize=36)
  ax.set_xlabel(r"$q$", fontsize=36)
  
  ax.legend(ncol=2, loc="lower right")
  
  qplot = np.linspace(0.5,2.0,100)
  TeRatiosplot = np.sqrt(qplot)
  Te1plot = Tw0/TeRatiosplot
  Te2plot = Tw0*TeRatiosplot
  Tm1plot = Te1plot/3.46/h**2*(-1*(qplot<1) + 1*(qplot>=1))
  Tm2plot = Te2plot/3.46/h**2*(-1*(qplot<1) + 1*(qplot>=1))
  e1s, e2s, theta1s, theta2s = calc_eeqs(h, qplot, totmass, j, 0., 0.,
                                         -Tm1plot, -Tm2plot, Te1plot, Te2plot, secterms=True)
  ax.plot(qplot, np.abs(theta1s-theta2s)*deg_conv, ls="--", c="k")
  
  #e1s, e2s, theta1s, theta2s = calc_eeqs(HS[0], QS, totmass, j, 0., 0., -TM1, -TM2, TE1, TE2, secterms=False)
  #ax.plot(QS, np.abs(theta1s-theta2s)*deg_conv, ls="--", c="gray")
  ax.set_xscale("log")
  
  fig.subplots_adjust(wspace=.75)
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  print(f"standard-pomega-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}.png")
  fig.savefig(f"standard-pomega-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}.png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: No handles with labels found to put in legend.
: standard-pomega-Tm2--454146-Tw0-1000.png
[[file:./.ob-jupyter/c24658bc68fdbc7001d5bb53581474358e35fb3d.png]]
:END:

** example run
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  readme = "totmass q Te1 Te2 e1 e2 |g1-g2| \n " \
      "averages taken from 0.9xT; T = 20.xTe0; Te0=1000"
  #################
  # CONFIGURATION #
  #################
  j = 2
  a0 = 1.0
  alpha_0 = (j/(j+1))**(2./3.)
  #Nqs = 25
  #qs = np.logspace(-2, 2, Nqs)
  #Nqs = 10
  #qs = np.linspace(0.5,2,Nqs)
  qs = np.array([0.5, 0.75, 0.9, 1.1,1.5, 2.])
  Nqs = len(qs)
  overwrite = True
  totmass = 1e-3
  e0 = 0.001
  
  ######################
  # Varying parameters #
  ######################
  Tw0 = 1000.
  TeRatios = np.sqrt(qs)
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*H_SECTION
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = np.array(qs)
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  ALPHA_0 = alpha_0*np.ones(Nqs)
  TE1 = Tw0*TeRatios
  TE2 = Tw0/TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(1*(qs<1) - 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(1*(qs<1) - 1*(qs>=1))
  TS = 60.*np.maximum(TE1, TE2)
  print(TS)
  #E1_0 = np.minimum(0.1/sqrt(QS), 0.1*np.ones(Nqs))
  #E2_0 = np.minimum(0.1*sqrt(QS), 0.1*np.ones(Nqs))
  E1_0 = np.ones(Nqs)*e0
  E2_0 = np.ones(Nqs)*e0
  print(E1_0,E2_0)
  E1DS = np.zeros(Nqs)
  E2DS = np.zeros(Nqs)
  CUTOFFS = TS
  #ALPHA2_0 = (3/2.)**(2./3)*(1+E2_0**2+E1_0**2)
  ALPHA2_0 = (1.7)**(2./3)*np.ones(Nqs)
  
  NAMES = np.array([f"q{QS[i]:0.2f}" for i in range(Nqs)])
  
  DIRNAMES = np.array([f"standard-h-{HS[i]:0.2f}-Tw0-{int(Tw0)}"
                       for i in range(len(QS))])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"-nosec" for i in range(Nqs)])
  
  i = -1
  name = NAMES[i]
  print(name)
  data = np.load(os.path.join(DIRNAMES[i], name+".npz"))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  fontsize=24
  fig, ax = plt.subplots(3,2, figsize=(18,12))
  tscale = 1.
  
  iplt0 = np.where(teval > 1e2)[0][0]
  teval = teval[iplt0:]
  
  iplt = np.where(teval > 1e5)[0][0]
  
  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale, teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
  
  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2, alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2, alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  
  ax[0,1].scatter(teval[:iplt]/tscale, (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05, c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  
  ax[2,0].scatter(teval[:iplt]/tscale,e2[:iplt], s=2, alpha=0.05, c="r", label=r"$e_2$")
  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e$", fontsize=fontsize)
  ax[2,0].set_ylim(0, 0.03)
  ax[2,0].legend()
  C0 = mpl.lines.Line2D([], [], color='k', marker="o", linestyle='None',
                        markersize=10, label=r'$e_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o", linestyle='None',
                        markersize=10, label=r'$e_2$')
  
  ax[2,0].legend(handles=[C0, C1], loc="upper left", ncol=2)
  
  
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv, s=2, alpha=0.05, c="r")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[2,1].scatter(teval[:iplt]/tscale,np.abs(g1[:iplt]-g2[:iplt])*deg_conv, s=2, alpha=0.05, c="k")
  ax[2,1].set_ylabel(r"$|\varpi_1-\varpi_2|$", fontsize=fontsize)
  ax[2,1].set_ylim(120, 240)
  ax[2,1].axhline(y=180., c="green", ls="--", lw=3, label="$180^\circ$")
  ax[2,1].legend()
  
  fig.subplots_adjust(hspace=0.4, wspace=0.2)
  
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(f"standard-example-h-{h}-Tw0-{int(Tw0)}.png", bbox_inches="tight")
  print(f"standard-example-h-{h}-Tw0-{int(Tw0)}.png")
  print(TM1[i],TM2[i],TE1[i],TE2[i],QS[i])
#+END_SRC

#+RESULTS:
:RESULTS:
: [84852.81374239 69282.03230276 63245.55320337 62928.53089021
:  73484.6922835  84852.81374239]
: [0.001 0.001 0.001 0.001 0.001 0.001] [0.001 0.001 0.001 0.001 0.001 0.001]
: q2.00
: standard-example-h-0.03-Tw0-1000.png
: -454146.9371782579 -227073.46858912893 1414.213562373095 707.1067811865474 2.0
[[file:./.ob-jupyter/053f35574560ff748b6ad8f509cb419b584da3da.png]]
:END:

* MMR Hamiltonian
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fontsize = 30
  def Hhat_Rtheta(R, theta, delta):
      return(-3*(delta+1)*R+R**2-2*np.sqrt(2*R)*np.cos(theta))
  def Hhat_xinu(xi, nu, delta):
      return(-3*(delta+1)*(xi**2+nu**2)
             +(xi**2+nu**2)**2-2*np.sqrt(2)*xi)
  fig, ax = plt.subplots(1,3,figsize=(19,6))
  xpos = np.linspace(-5,-0.01,500)
  xneg = np.linspace(0.01,5,500)
  deltapos = -1+(1./3./xpos)*(-sqrt(2) + 2*xpos**3)
  deltaneg = -1+(1./3./xneg)*(-sqrt(2) + 2*xneg**3)
  ax[0].plot(xpos, deltapos, c="k")
  ax[0].plot(xneg, deltaneg, c="k")
  
  deltares = np.linspace(0,10,1000) 
  x1s = np.zeros(len(deltares))
  x2s = np.zeros(len(deltares))
  x3s = np.zeros(len(deltares))
  x4s = np.zeros(len(deltares))
  for i, d0 in enumerate(deltares):
      p = np.array([2,0,-3*(d0+1), -sqrt(2)])
      proots = np.roots(p)
      xi = np.min(proots)
      H0 = Hhat_xinu(xi, 0., d0)
      q = np.array([1,0,-3*(d0+1),-2*np.sqrt(2),-H0])
      qroots = np.sort(np.roots(q))
      x1s[i] = qroots[0]
      x2s[i] = qroots[1]
      x3s[i] = qroots[2]
      x4s[i] = qroots[3]
  
  ax[0].plot(x3s, deltares, c="r")
  ax[0].plot(x4s, deltares, c="r")
  ax[0].fill_betweenx(deltares, x3s, x4s, color="r", alpha=0.1)
  #print(x3s)
  
  #idcross = np.argmin(x2s)
  #ax.plot(x2s[idcross:], deltapos[idcross:], c="r")
  #ax.plot(x4s, deltapos, c="r")
  
  ax[0].set_xlim((-5,5))
  ax[0].set_ylim((-5,5))
  ax[0].set_xlabel(r"$\xi$", fontsize=32)
  ax[0].set_ylabel(r"$\delta$", fontsize=32)
  
  
  R = np.linspace(0, 8, 1000)
  t = np.linspace(0, 2*np.pi, 1000)
  RR, TT = np.meshgrid(R,t)
  
  delta = -0.5
  ax[0].axhline(y=delta, ls="--", c="green")
  XX = RR*np.cos(TT)
  YY = RR*np.sin(TT)
  levels = np.linspace(-2, 20, 8)
  p = np.array([2,0,-3*(delta+1), -sqrt(2)])
  proots = np.roots(p)
  xi = np.max(proots)
  ax[0].scatter(xi,delta,marker="x",c="cyan",s=100)
  H0 = Hhat_xinu(xi, 0., delta)
  ax[1].contour(XX, YY, Hhat_Rtheta(RR,TT,delta), levels=levels, colors="k", linestyles="-")
  ax[1].scatter(xi**2,0,marker="x",c="cyan",s=100)
  ax[1].text(-7, -7, r"$\delta=$ "+f"{delta:0.1f}", fontsize=32 )
  
  delta = 1
  ax[0].axhline(y=delta, ls="--", c="green")
  p = np.array([2,0,-3*(delta+1), -sqrt(2)])
  proots = np.roots(p)
  xi = np.min(proots)
  ax[0].scatter(proots,delta*np.ones(len(proots)),marker="x",c="magenta",s=100)
  H0 = Hhat_xinu(xi, 0., delta)
  levels = H0*np.flip(np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0]))
  print(levels)
  ax[2].scatter(proots**2*np.sign(proots), np.zeros(len(proots)), marker="x",c="magenta",s=100)
  ax[2].scatter(proots**2*np.sign(proots), np.zeros(len(proots)), marker="x",c="magenta",s=100)
  ax[2].contour(XX, YY, Hhat_Rtheta(RR,TT,delta), levels=levels, colors="k", linestyles="-")
  ax[2].text(-7, -7, r"$\delta=$ "+f"{delta:0.1f}", fontsize=32 )
  
  for axi in ax:
      axi.axhline(y=0., ls="--", c="k", lw=1)
      axi.axvline(x=0., ls="--", c="k", lw=1)
      axi.tick_params(which="major", labelsize=fontsize, width=3,
                        length=8, bottom=True, top=True, left=True, right=True,
                        direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3,
                        length=4, bottom=True, top=True, left=True, right=True,
                        direction="in", pad=10)
  fig.subplots_adjust(wspace=0.35)
  ax[1].set_ylabel(r"$R\sin\theta$",fontsize=32)
  ax[2].set_ylabel(r"$R\sin\theta$",fontsize=32)
  ax[1].set_xlabel(r"$R\cos\theta$",fontsize=32)
  ax[2].set_xlabel(r"$R\cos\theta$",fontsize=32)
  
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(f"phasediag.png", bbox_inches="tight")
  
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
  <ipython-input-96-74255f52bd12>:27: ComplexWarning: Casting complex values to real discards the imaginary part
    x1s[i] = qroots[0]
  <ipython-input-96-74255f52bd12>:28: ComplexWarning: Casting complex values to real discards the imaginary part
    x2s[i] = qroots[1]
  <ipython-input-96-74255f52bd12>:29: ComplexWarning: Casting complex values to real discards the imaginary part
    x3s[i] = qroots[2]
  <ipython-input-96-74255f52bd12>:30: ComplexWarning: Casting complex values to real discards the imaginary part
    x4s[i] = qroots[3]
  /home/jtlaune/.pythonvenvs/science/lib/python3.9/site-packages/matplotlib/collections.py:206: ComplexWarning: Casting complex values to real discards the imaginary part
    offsets = np.asanyarray(offsets, float)
  [-12.84276218 -10.70230182  -8.56184145  -6.42138109  -4.28092073
    -2.14046036]
#+end_example
[[file:./.ob-jupyter/93e0e081aefbe5404bd07c0507ba1dc6a85bec19.png]]
:END:

* vary Te
** get results
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  readme = ""
  qs = [0.5, 1., 2.]
  h=0.03
  
  for q in qs:
      #################
      # CONFIGURATION #
      #################
      j = 2
      a0 = 1.0
      alpha_0 = (j/(j+1))**(2./3.)
      overwrite = True
      totmass = 1e-3
  
      ######################
      # Varying parameters #
      ######################
      Tw0 = 1000.
      rats = np.array([0.25, 0.5, 0.75, 1.5, 2.5, 5, 10])
      TeRatios = np.sqrt(rats)
      Nqs = len(TeRatios)
      qs = np.ones(Nqs)*q
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = np.array(qs)
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
      ALPHA_0 = alpha_0*np.ones(Nqs)
      TE1 = Tw0*TeRatios
      TE2 = Tw0/TeRatios
      TM1 = TE1/3.46/HS**2*(1*(TeRatios<1) - 1*(TeRatios>=1))
      TM2 = TE2/3.46/HS**2*(1*(TeRatios<1) - 1*(TeRatios>=1))
      TS = 8.*np.maximum(TE1, TE2)
      E1_0 = np.ones(Nqs)*0.1/sqrt(QS)
      E2_0 = np.ones(Nqs)*0.1*sqrt(QS)
      E1DS = np.zeros(Nqs)
      E2DS = np.zeros(Nqs)
      CUTOFFS = TS
      ALPHA2_0 = (3/2.)**(2./3)*(1+E2_0**2+E1_0**2)
      NAMES = np.array([f"ratio-{rats[i]}" for i in range(len(QS))])
  
      DIRNAMES = np.array([f"./varyTe-q{QS[i]}-h-{h}-Tw0-{int(Tw0)}" for i in range(Nqs)])
      print(DIRNAMES)
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"-nosec" for i in range(Nqs)])
  
      ################
      # WITH SECULAR #
      ################
      results_arr = np.zeros((Nqs, 10))
      results_arr[:,0] = totmass
      results_arr[:,1] = QS
      results_arr[:,2] = TE1
      results_arr[:,3] = TE2
      for i, name in enumerate(NAMES):
          data = np.load(os.path.join(DIRNAMES[i], name+".npz"))
          teval  = data["teval"]
          theta  = data["thetap"]
          a1     = data["a1"]
          a2     = data["a2"]
          e1     = data["e1"]
          e2     = data["e2"]
          g1     = data["g1"]
          g2     = data["g2"]
          L1     = data["L1"]
          L2     = data["L2"]
          x1     = data["x1"]
          y1     = data["y1"]
          x2     = data["x2"]
          y2     = data["y2"]
  
          it = int(len(teval)*0.9)
  
          results_arr[i,4] = np.average(e1[it:])
          results_arr[i,5] = np.average(e2[it:])
          results_arr[i,6] = np.average(np.abs(g1[it:]-g2[it:]))
          results_arr[i,7] = np.std(e1[it:])
          results_arr[i,8] = np.std(e2[it:])
          results_arr[i,9] = np.std(np.abs(g1[it:]-g2[it:]))
      np.savetxt(f"varyTe-q{q}-h-{h}-Tw0-{int(Tw0)}.txt", results_arr, header=readme)
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
#+END_SRC

#+RESULTS:
#+begin_example
  ['./varyTe-q0.5-h-0.03-Tw0-1000' './varyTe-q0.5-h-0.03-Tw0-1000'
   './varyTe-q0.5-h-0.03-Tw0-1000' './varyTe-q0.5-h-0.03-Tw0-1000'
   './varyTe-q0.5-h-0.03-Tw0-1000' './varyTe-q0.5-h-0.03-Tw0-1000'
   './varyTe-q0.5-h-0.03-Tw0-1000']
  ['./varyTe-q1.0-h-0.03-Tw0-1000' './varyTe-q1.0-h-0.03-Tw0-1000'
   './varyTe-q1.0-h-0.03-Tw0-1000' './varyTe-q1.0-h-0.03-Tw0-1000'
   './varyTe-q1.0-h-0.03-Tw0-1000' './varyTe-q1.0-h-0.03-Tw0-1000'
   './varyTe-q1.0-h-0.03-Tw0-1000']
  ['./varyTe-q2.0-h-0.03-Tw0-1000' './varyTe-q2.0-h-0.03-Tw0-1000'
   './varyTe-q2.0-h-0.03-Tw0-1000' './varyTe-q2.0-h-0.03-Tw0-1000'
   './varyTe-q2.0-h-0.03-Tw0-1000' './varyTe-q2.0-h-0.03-Tw0-1000'
   './varyTe-q2.0-h-0.03-Tw0-1000']
#+end_example

** eeq eccentricities
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  qs = [0.5, 1., 2.]
  TM2 = -np.ones(Nqs)*5e4
  fig, ax = plt.subplots(3, figsize=(8,14), sharex=True)
  fontsize=32
  for i,q in enumerate(qs):
      results = np.loadtxt(f"varyTe-q{q}-h-{h}-Tw0-{int(Tw0)}.txt")
      Te1 = results[:,2]
      Te2 = results[:,3]
      ratio = Te1/Te2
      e1avg = results[:,4]
      e2avg = results[:,5]
      Dpomega = results[:,6]
      e1avg_std = results[:,7]
      e2avg_std = results[:,8]
      Dpomega_std = results[:,9]
      ax[i].errorbar(ratio, e1avg, yerr=e1avg_std, c="k", label=f"$e_1$", fmt="o", capsize=2)
      ax[i].errorbar(ratio, e2avg, yerr=e2avg_std, c="r", label=f"$e_2$", fmt="o", capsize=2)
      ax[i].tick_params(which="both", labelsize=fontsize)
      #ax[i].set_ylim((0., 0.05))
  
  ############
  # FIX THIS #
  ############
  
      Nplot = 100
      qplot = np.ones(Nplot)*q
      ratsplot = np.logspace(-1,1,Nplot)
      TeRatiosplot = np.sqrt(ratsplot)
      Te1plot = Tw0*TeRatiosplot
      Te2plot = Tw0/TeRatiosplot
      Tm1plot = Te1plot/3.46/h**2*(1*(TeRatiosplot<1) - 1*(TeRatiosplot>=1))
      Tm2plot = Te2plot/3.46/h**2*(1*(TeRatiosplot<1) - 1*(TeRatiosplot>=1))
      e1s, e2s, theta1s, theta2s = calc_eeqs(h, qplot, totmass, j, 0.,
                                             0., -Tm1plot, -Tm2plot, Te1plot, Te2plot, secterms=True)
      #print(ratio)
      #print(e1s)
      #print(e2s)
      ax[i].plot(ratsplot, e1s, ls="--", c="k")
      ax[i].plot(ratsplot, e2s, ls="--", c="r")
  
  
      ## there is no difference
      #results = np.loadtxt(f"varyTe-q{q}-h-{h}-Tw0-{int(Tw0)}-nosec.txt")
      #Te1 = results[:,2]
      #Te2 = results[:,3]
      #ratio = Te1/Te2
      #e1avg = results[:,4]
      #e2avg = results[:,5]
      #Dpomega = results[:,6]
      #ax[i].scatter(ratio, e1avg, marker="x", c="k", s=20)
      #ax[i].scatter(ratio, e2avg, marker="x", c="r", s=20)
  
      ax[i].tick_params(which="major", labelsize=fontsize, width=3, length=8,
                     bottom=True, top=True, left=True, right=True,
                     direction="in", pad=10)
      ax[i].tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                     bottom=True, top=True, left=True, right=True,
                     direction="in", pad=10)
      ax[i].set_yticks([0.01, 0.03, 0.06, 0.09])
      ax[i].set_ylim((0.0,0.03))
      ax[i].set_xscale("log")
  
      ax[i].set_ylabel(r"$e$", fontsize=fontsize)
      ax[i].text(0.1, 0.1, r"$q=$ "+f"{q}", fontsize=fontsize, transform=ax[i].transAxes)
  
  #ax[0].set_title("Eccentricity", fontsize=40, pad=20)
  ax[0].legend(ncol=2)
  ax[-1].set_xlabel(r"$T_{e,1}/T_{e,2}$", fontsize=fontsize)
  
  fig.subplots_adjust(wspace=.75, hspace=0.)
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(f"varyTe-eeqs-h-{h}-Tw0-{int(Tw0)}.png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/98ae2193587ec90bcd951b01ae8b118a3c45158e.png]]

** Dpomega
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  qs = [0.5, 1., 2.]
  TM2 = -np.ones(Nqs)*5e4
  fig, ax = plt.subplots(3, figsize=(8,14), sharex=True)
  fontsize=32
  
  palette = ["black", "red", "blue"]
  sns.set_palette(sns.color_palette(palette))
  
  for i,q in enumerate(qs):
      results = np.loadtxt(f"varyTe-q{q}-h-{h}-Tw0-{int(Tw0)}.txt")
      Te1 = results[:,2]
      Te2 = results[:,3]
      ratio = Te1/Te2
      e1avg = results[:,4]
      e2avg = results[:,5]
      Dpomega = results[:,6]
      e1avg_std = results[:,7]
      e2avg_std = results[:,8]
      Dpomega_std = results[:,9]*deg_conv
      ax[i].errorbar(ratio, Dpomega*deg_conv, yerr=Dpomega_std,
                     label=r"$\Delta\varpi$", c=f"k", capsize=2,
                     fmt="o",markersize=5,zorder=10)
  
      ax[i].tick_params(which="major", labelsize=fontsize, width=3, length=8,
                     bottom=True, top=True, left=True, right=True,
                     direction="in", pad=10)
      ax[i].tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                     bottom=True, top=True, left=True, right=True,
                     direction="in", pad=10)
      ax[i].yaxis.set_major_locator(MaxNLocator(4))
      ax[i].set_ylabel(r"$\Delta\varpi$", fontsize=fontsize)
      ax[i].text(0.1, 0.1, r"$q=$ "+f"{q}", fontsize=fontsize, transform=ax[i].transAxes)
      ax[i].tick_params(which="both", labelsize=fontsize)
      ax[i].set_xscale("log")
  
      ax[i].set_yticks([175, 180, 185 ])
      ax[i].set_ylim((177,183))
  
      Nplot = 100
      qplot = np.ones(Nplot)*q
      ratsplot = np.logspace(-1,1,Nplot)
      TeRatiosplot = np.sqrt(ratsplot)
      Te1plot = Tw0*TeRatiosplot
      Te2plot = Tw0/TeRatiosplot
      Tm1plot = Te1plot/3.46/h**2*(1*(TeRatiosplot<1) - 1*(TeRatiosplot>=1))
      Tm2plot = Te2plot/3.46/h**2*(1*(TeRatiosplot<1) - 1*(TeRatiosplot>=1))
      e1s, e2s, theta1s, theta2s = calc_eeqs(h, qplot, totmass, j, 0.,
                                             0., -Tm1plot, -Tm2plot, Te1plot, Te2plot, secterms=True)
  
      ax[i].plot(ratsplot, deg_conv*np.abs(theta1s-theta2s), ls="--", c="k")
  
  ax[-1].set_xlabel(r"$T_{e,1}/T_{e,2}$", fontsize=fontsize)
  fig.subplots_adjust(wspace=1.0, hspace=0.)
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(f"varyTe-pomega-h-{h}-Tw0-{int(Tw0)}.png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/2a7a8dafd91cbf9fb7f6fe7b408c0d030ad135a9.png]]

* analytic vary Te
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  for q in [0.5, 1., 2.]:
      Tm2 = -5e4
      Tw0 = 1e3
      results = np.loadtxt(f"q{q}-Tm2-{-int(Tm2)}-Tw0-{int(Tw0)}.txt")
      Te1 = results[:,2]
      Te2 = results[:,3]
      ratio = Te1/Te2
      e1avg = results[:,4]
      e2avg = results[:,5]
      Dpomega = results[:,6]
  
      alpha_0 = (j/(j+1))**(2./3.)
      gamma = q*sqrt(alpha_0)
      delta = j*(q/alpha_0 + 1)
      eps2 = np.abs(ratio/(delta-1)*(0.5*Te2/e2avg**2/Tm2 + delta/gamma - 1))
      eps = sqrt(eps2) # fudge factor by eye at front
  
      #plt.plot(ratio, eps)
      plt.scatter(ratio, eps/(e1avg/e2avg))
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/17e8df58b92a3acfc795ea40c5abcd32185afd3b.png]]

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  j = 2
  N = 1000
  Tw0 = 1000
  Tm2 = 5e-4
  TeRatios = np.linspace(0.1,10,N)
  q = 0.5
  alpha0 = (j/(j+1))**(2./3)
  sqrtalpha0 = sqrt(alpha0)
  sigma = (q*sqrtalpha0/j/(q*sqrtalpha0+1))*(TeRatios)
  eps2 = np.abs((1+1/sigma)/(1-q*sqrtalpha0/sigma))
  eps = sqrt(eps2)
  e0 = 0.05
  e1 = e0*sqrt(eps)
  e2 = e0/sqrt(eps)
  plt.plot(TeRatios, e1)
  plt.plot(TeRatios, e2)
  plt.twinx().plot(TeRatios, eps,c="r")
#+END_SRC

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7fa8e2f09fd0> |
[[file:./.ob-jupyter/3867c8f349edcf40cfffd3445e4ecea67f55289c.png]]
:END:

* vary q
** get results
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  ratios = [0.1, 0.5, 1.0, 2., 10.]
  
  for ratio in ratios:
      #################
      # CONFIGURATION #
      #################
      j = 2
      a0 = 1.0
      alpha_0 = (j/(j+1))**(2./3.)
      Nqs = 5
      qs = np.linspace(0.5, 2., Nqs)
      overwrite = False
      totmass = 1e-3
  
      ######################
      # Varying parameters #
      ######################
      Tw0 = 1000.
      TeRatios = np.sqrt(np.linspace(0.1, 10, Nqs))
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.zeros(Nqs)
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = np.array(qs)
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
      TM1 = np.ones(Nqs)*np.infty
      TM2 = -np.ones(Nqs)*5e4
      ALPHA_0 = alpha_0*np.ones(Nqs)
      TE1 = Tw0*ratio*np.ones(Nqs)
      TE2 = Tw0/ratio*np.ones(Nqs)
      TS = 5.*np.maximum(TE1, TE2)
      E1_0 = np.ones(Nqs)*0.1/sqrt(QS)
      E2_0 = np.ones(Nqs)*0.1*sqrt(QS)
      E1DS = np.zeros(Nqs)
      E2DS = np.zeros(Nqs)
      CUTOFFS = TS
      ALPHA2_0 = (3/2.)**(2./3)*(1+E2_0**2+E1_0**2)
  
      NAMES = np.array([f"q{QS[i]:0.2f}" for i in range(Nqs)])
  
      DIRNAMES = np.array([f"Teratio-{ratio:0.1f}-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}" for i in range(len(QS))])
      #print(NAMES)
      #print(DIRNAMES)
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"-nosec" for i in range(Nqs)])
  
      ################
      # WITH SECULAR #
      ################
      results_arr = np.zeros((Nqs, 7))
      results_arr[:,0] = totmass
      results_arr[:,1] = QS
      results_arr[:,2] = TE1
      results_arr[:,3] = TE2
      for i, name in enumerate(NAMES):
          data = np.load(os.path.join(DIRNAMES[i], name+".npz"))
          teval  = data["teval"]
          theta  = data["thetap"]
          a1     = data["a1"]
          a2     = data["a2"]
          e1     = data["e1"]
          e2     = data["e2"]
          g1     = data["g1"]
          g2     = data["g2"]
          L1     = data["L1"]
          L2     = data["L2"]
          x1     = data["x1"]
          y1     = data["y1"]
          x2     = data["x2"]
          y2     = data["y2"]
  
          it = int(len(teval)*0.9)
  
          results_arr[i,4] = np.average(e1[it:])
          results_arr[i,5] = np.average(e2[it:])
          results_arr[i,6] = np.average(np.abs(g1-g2))
      np.savetxt(f"Teratio-{ratio}-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}-results.txt", results_arr, header=readme)
  
      ###################
      # WITHOUT SECULAR #
      ###################
      results_arr = np.zeros((Nqs, 7))
      results_arr[:,0] = totmass
      results_arr[:,1] = QS
      results_arr[:,2] = TE1
      results_arr[:,3] = TE2
      for i, name in enumerate(NAMES):
          data = np.load(os.path.join(DIRNAMES[i], name+".npz"))
          teval  = data["teval"]
          theta  = data["thetap"]
          a1     = data["a1"]
          a2     = data["a2"]
          e1     = data["e1"]
          e2     = data["e2"]
          g1     = data["g1"]
          g2     = data["g2"]
          L1     = data["L1"]
          L2     = data["L2"]
          x1     = data["x1"]
          y1     = data["y1"]
          x2     = data["x2"]
          y2     = data["y2"]
  
          it = int(len(teval)*0.9)
  
          results_arr[i,4] = np.average(e1[it:])
          results_arr[i,5] = np.average(e2[it:])
          results_arr[i,6] = np.average(np.abs(g1-g2))
  
      np.savetxt(f"Teratio-{ratio:0.1f}-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}-results-nosec.txt", results_arr, header=readme)
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
#+END_SRC

#+RESULTS:

** eq ecc

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  readme = "totmass q Te1 Te2 e1 e2 |g1-g2| \n " \
           "averages taken from 0.9xT; T = 20.xTe0; Te0=1000"
  TM2 = -np.ones(Nqs)*5e4
  fig, ax = plt.subplots(1,5,figsize=(30,5))
  ratios = [0.1, 0.5, 1.0, 2., 10.]
  fontsize=32
  for i,ratio in enumerate(ratios):
      print(ratio)
      results = np.loadtxt(f"Teratio-{ratio:0.1f}-Tm2-{-int(TM2[0])}-Tw0-{int(Tw0)}-results.txt")
      Te1 = results[:,2]
      Te2 = results[:,3]
      e1avg = results[:,4]
      e2avg = results[:,5]
      Dpomega = results[:,6]
      qs = np.linspace(0.5, 2., Nqs)
      ax[i].scatter(qs, e1avg, c="C0", label=r"$e_1$")
      ax[i].scatter(qs, e2avg, c="C1", label=r"$e_2$")
      ax[i].tick_params(which="both", labelsize=fontsize)
      ax[i].set_ylim((0., 0.07))
      ax[i].set_title(r"$T_{e,1}/T_{e,2} = $"+f"{ratio:0.1f}", fontsize=fontsize)
  
      # there is no difference
      #results = np.loadtxt(f"Teratio-{ratio:0.1f}-Tm2-{-int(TM2[0])}-Tw0-{int(Tw0)}-results-nosec.txt")
      #Te1 = results[:,2]
      #Te2 = results[:,3]
      #e1avg = results[:,4]
      #e2avg = results[:,5]
      #Dpomega = results[:,6]
      #qs = np.linspace(0.5, 2., Nqs)
      #ax[i].scatter(qs, e1avg, marker="x", c="k", label=r"w/o sec.")
      #ax[i].scatter(qs, e2avg, marker="x", c="r", label=r"w/o sec.")
  
      ax[i].set_ylabel(r"$e$", fontsize=fontsize)
      ax[i].set_xlabel(r"$q$", fontsize=fontsize)
  
  ax[0].legend(ncol=2, loc="best")
  fig.subplots_adjust(wspace=.75)
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(f"Teratio-eeqs-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}.png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: 0.1
: 0.5
: 1.0
: 2.0
: 10.0
[[file:./.ob-jupyter/2d6111eb8a9021a8f35c6c0bd56ef6dd1604756b.png]]
:END:

** eq Dpomega
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  readme = "totmass q Te1 Te2 e1 e2 |g1-g2| \n " \
           "averages taken from 0.9xT; T = 20.xTe0; Te0=1000"
  TM2 = -np.ones(Nqs)*5e4
  fig, ax = plt.subplots(figsize=(5,5))
  ratios = [0.1, 0.5, 1.0, 2., 10.]
  fontsize=24
  for i,ratio in enumerate(ratios):
      results = np.loadtxt(f"Teratio-{ratio:0.1f}-Tm2-{-int(TM2[0])}-Tw0-{int(Tw0)}-results.txt")
      Te1 = results[:,2]
      Te2 = results[:,3]
      e1avg = results[:,4]
      e2avg = results[:,5]
      Dpomega = results[:,6]
      qs = np.linspace(0.5, 2., Nqs)
      ax.plot(qs, Dpomega, c=f"C{i}", label=f"{ratio}")
      ax.tick_params(which="both", labelsize=fontsize)
      ax.set_title(r"$T_{e,1}/T_{e,2} $", fontsize=fontsize,pad=110)
  
      # there is no difference
      #results = np.loadtxt(f"Teratio-{ratio:0.1f}-Tm2-{-int(TM2[0])}-Tw0-{int(Tw0)}-results-nosec.txt")
      #Te1 = results[:,2]
      #Te2 = results[:,3]
      #e1avg = results[:,4]
      #e2avg = results[:,5]
      #Dpomega = results[:,6]
      #qs = np.linspace(0.5, 2., Nqs)
      #ax[i].scatter(qs, Dpomega, marker="x", c="C1", label=r"w/o sec.")
  
      ax.set_ylabel(r"$\Delta\varpi$", fontsize=fontsize)
      ax.set_xlabel(r"$q$", fontsize=fontsize)
  
  ax.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc='lower left',
           ncol=2, mode="expand", borderaxespad=0.)
  fig.subplots_adjust(wspace=.75)
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(f"Teratio-pomega-Tm2-{-int(TM2[i])}-Tw0-{int(Tw0)}.png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
#+attr_org: :width 343
[[file:./.ob-jupyter/0ac16b784739be9da17c5b8d01132fa656f8cff9.png]]
:END:

* ecc driving force
** example
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/Rhat-grid/")
  prefix = "inres"
  q = 2.0
  #################
  # CONFIGURATION #
  #################
  h = 0.03
  j = 2
  a0 = 1.0
  qRun = 9
  Nqs = 9
  qs = np.ones(Nqs)*q
  overwrite = True
  totmass = 1.0e-4
  Tw0 = 1000
  TeRatios = sqrt(qs)
  
  ######################
  # Varying parameters #
  ######################
  E1_0 = np.ones(Nqs)*0.001
  E2_0 = np.ones(Nqs)*0.001
  
  e1ds = np.linspace(0,0.2,3)
  e2ds = np.linspace(0,0.2,3)
  
  E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
  E1DS_single = E1DS_single.flatten()
  E2DS_single = E2DS_single.flatten()
  
  E1DS = np.array([])
  E2DS = np.array([])
  for i in range(int(Nqs/qRun)):
      E1DS = np.append(E1DS, E1DS_single)
      E2DS = np.append(E2DS, E2DS_single)
  print(len(E1DS))
  
  G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  
  TE_FUNCS = np.zeros(Nqs)
  TE1 = Tw0/TeRatios
  TE2 = Tw0*TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TS = 30.*np.maximum(TE1, TE2)
  #############################################################
  # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
  # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
  #############################################################
  cutoff_frac = 1.0
  CUTOFFS = TS*cutoff_frac
  NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                    for i, qit in enumerate(QS)])
  
  DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                          in range(Nqs)])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
  i = 2
  dirname = DIRNAMES[i]
  name = NAMES[i]+".npz"
  print(name)
  data = np.load(os.path.join(dirname, name))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  
  fontsize=24
  fig, ax = plt.subplots(4,2, figsize=(18,16))
  tscale = 1.
  
  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]
  
  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)
  
  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2, alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2, alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  ax[0,0].set_ylim((0.9, 1.7))
  C0 = mpl.lines.Line2D([], [], color='k', marker="o", linestyle='None',
                        markersize=10, label=r'$a_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o", linestyle='None',
                        markersize=10, label=r'$a_2$')
  ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)
  
  ax[0,1].scatter(teval[:iplt]/tscale, (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05, c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  ax[0,1].patch.set_visible(False)
  #ax[0,1].set_ylim((1.5,1.75))
  
  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e_1$", fontsize=fontsize)
  ax[2,0].set_ylim(0, 0.3)
  
  ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,1].set_ylabel(r"$e_2$", fontsize=fontsize)
  ax[2,1].set_ylim(0, 0.3)
  
  ax[3,0].scatter(teval[:iplt]/tscale, deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
  ax[3,0].set_ylim((0., 360.))
  ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)
  
  
  Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
  Dpom = Dpom - 2*pi*(Dpom>pi)
  ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2, alpha=0.05, c="k")
  ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
  ax[3,1].set_ylim((-180., 180.))
  ax[3,1].axhline(y=0., c="r", ls="--", lw=3, label="$180^\circ$")
  #ax[3,1].legend()
  
  fig.subplots_adjust(hspace=0.4, wspace=0.2)
  
  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale, teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
  
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  figname = f"{prefix}-driving-example-h-{h}-Tw0-{int(Tw0)}-q{q}.png"
  print(figname)
  fig.savefig(figname, bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: 9
: e1d-0.200-e2d-0.000.npz
: inres-driving-example-h-0.03-Tw0-1000-q2.0.png
[[file:./.ob-jupyter/b09cca685ebc99d519608c6250cb2b26b58c5f8d.png]]
:END:
** perp example
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/Rhat-grid/")
  prefix="inres"
  #################
  # CONFIGURATION #
  #################
  h = 0.03
  j = 2
  a0 = 1.0
  qRun = 9
  Nqs = 9
  qs = np.ones(Nqs)*2
  overwrite = True
  totmass = 1.0e-4
  Tw0 = 1000
  TeRatios = sqrt(qs)
  
  ######################
  # Varying parameters #
  ######################
  E1_0 = np.ones(Nqs)*0.001
  E2_0 = np.ones(Nqs)*0.001
  
  e1ds = np.linspace(0,0.2,3)
  e2ds = np.linspace(0,0.2,3)
  
  E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
  E1DS_single = E1DS_single.flatten()
  E2DS_single = E2DS_single.flatten()
  
  E1DS = np.array([])
  E2DS = np.array([])
  for i in range(int(Nqs/qRun)):
      E1DS = np.append(E1DS, E1DS_single)
      E2DS = np.append(E2DS, E2DS_single)
  print(len(E1DS))
  
  G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  
  TE_FUNCS = np.zeros(Nqs)
  TE1 = Tw0/TeRatios
  TE2 = Tw0*TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TS = 30.*np.maximum(TE1, TE2)
  #############################################################
  # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
  # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
  #############################################################
  cutoff_frac = 1.0
  CUTOFFS = TS*cutoff_frac
  NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                    for i, qit in enumerate(QS)])
  
  DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                          in range(Nqs)])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
  i = 6
  dirname = DIRNAMES[i]
  name = NAMES[i]+".npz"
  print(name)
  data = np.load(os.path.join(dirname, name))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  
  fontsize=24
  fig, ax = plt.subplots(4,2, figsize=(18,16))
  tscale = 1.
  
  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]
  
  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)
  
  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2, alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2, alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  ax[0,0].set_ylim((0.9, 1.7))
  C0 = mpl.lines.Line2D([], [], color='k', marker="o", linestyle='None',
                        markersize=10, label=r'$a_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o", linestyle='None',
                        markersize=10, label=r'$a_2$')
  ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)
  
  ax[0,1].scatter(teval[:iplt]/tscale, (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05, c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  ax[0,1].patch.set_visible(False)
  #ax[0,1].set_ylim((1.5,1.75))
  
  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e_1$", fontsize=fontsize)
  ax[2,0].set_ylim(0, 0.4)
  
  ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,1].set_ylabel(r"$e_2$", fontsize=fontsize)
  ax[2,1].set_ylim(0, 0.4)
  
  ax[3,0].scatter(teval[:iplt]/tscale, deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
  ax[3,0].set_ylim((0., 360.))
  ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)
  
  
  Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
  Dpom = Dpom - 2*pi*(Dpom>pi)
  ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2, alpha=0.05, c="k")
  ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
  ax[3,1].set_ylim((-180., 180.))
  ax[3,1].axhline(y=90., c="r", ls="--", lw=3, label="$180^\circ$")
  #ax[3,1].legend()
  
  fig.subplots_adjust(hspace=0.4, wspace=0.2)
  
  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale, teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
  
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  filename = f"{prefix}-driving-perpendicular-example-h-{h}-Tw0-{int(Tw0)}-q{q:0.1f}.png"
  fig.savefig(filename, bbox_inches="tight")
  print(filename)
#+END_SRC

#+RESULTS:
:RESULTS:
: 9
: e1d-0.000-e2d-0.200.npz
: inres-driving-perpendicular-example-h-0.03-Tw0-1000-q2.0.png
[[file:./.ob-jupyter/9f4c810986f50bffff720d7ed5ef5a5902afe194.png]]
:END:
** grid
*** gen behaviortxt
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
  
  prefix = "closeres"
  q = 0.5
  
  #################
  # CONFIGURATION #
  #################
  h = 0.03
  j = 2
  a0 = 0.7
  qRun = 9
  Nqs = 9
  qs = np.ones(Nqs)*q
  overwrite = True
  totmass = 1.0e-4
  Tw0 = 1000
  TeRatios = sqrt(qs)
  
  ######################
  # Varying parameters #
  ######################
  E1_0 = np.ones(Nqs)*0.001
  E2_0 = np.ones(Nqs)*0.001
  
  e1ds = np.linspace(0,0.2,3)
  e2ds = np.linspace(0,0.2,3)
  
  E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
  E1DS_single = E1DS_single.flatten()
  E2DS_single = E2DS_single.flatten()
  
  E1DS = np.array([])
  E2DS = np.array([])
  for i in range(int(Nqs/qRun)):
      E1DS = np.append(E1DS, E1DS_single)
      E2DS = np.append(E2DS, E2DS_single)
  print(len(E1DS))
  
  G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  
  TE_FUNCS = np.zeros(Nqs)
  TE1 = Tw0/TeRatios
  TE2 = Tw0*TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TS = 30.*np.maximum(TE1, TE2)
  #############################################################
  # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
  # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
  #############################################################
  cutoff_frac = 1.0
  CUTOFFS = TS*cutoff_frac
  NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                    for i, qit in enumerate(QS)])
  
  #ALPHA2_0 = (1.5)**(2./3)*np.ones(Nqs)
  #prefix = "inres"
  #ALPHA2_0 = (1.55)**(2./3)*np.ones(Nqs)
  DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                          in range(Nqs)])
  
  aligned_arr = np.zeros((Nqs, 13))
  aligned_arr[:,0] = totmass
  aligned_arr[:,1] = QS
  aligned_arr[:,2] = E1DS
  aligned_arr[:,3] = E2DS
  
  for i, filename in enumerate(NAMES):
      data = np.load(os.path.join(DIRNAMES[i], filename+".npz"))
      teval  = data["teval"]
      theta = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]
  
      it = int(len(teval)*0.9)
      #xi_avg = np.average(x1[it:]-x2[it:])
      #yi_avg = np.average(y1[it:]-y2[it:])
      Dpoms = g1[it:]-g2[it:]
      Dpom_avg = np.arctan2(np.sum(np.sin(Dpoms)), np.sum(np.cos(Dpoms)))
      Dpom_std = np.sqrt(np.sum(Dpoms-Dpom_avg)**2)/len(Dpoms)
  
      f1 = A(a1/a2, j)
      f2 = B(a1/a2, j)
      theta1 = theta + g1
      theta2 = theta + g2
      hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                            e1*cos(theta1) + f2/f1*e2*cos(theta2))
      hattheta1s = hattheta1s[it:]
      hattheta1_avg = np.arctan2(np.sum(np.sin(hattheta1s)), np.sum(np.cos(hattheta1s)))
      hattheta1_std = np.sqrt(np.sum(hattheta1s-hattheta1_avg)**2)/len(hattheta1s)
  
      inres = np.all(np.abs(hattheta1s) > 1.)
  
      aligned_arr[i,4] = np.average(e1[it:])
      aligned_arr[i,5] = np.std(e1[it:])
      aligned_arr[i,6] = np.average(e2[it:])
      aligned_arr[i,7] = np.std(e2[it:])
      aligned_arr[i,8] = Dpom_avg
      aligned_arr[i,9] = Dpom_std
      aligned_arr[i,10] = hattheta1_avg
      aligned_arr[i,11] = hattheta1_std
      aligned_arr[i,12] = inres
  np.savetxt(os.path.join(".", f"behaviors-{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[0]}.txt"), aligned_arr)
  
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
  h = 0.03
  totmass = 1e-4
  filename = f"behaviors-{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{q:0.1f}.txt"
  qRun = 16
  QS_it = [2.0]
  fig, ax = plt.subplots(len(QS_it)*1,2,figsize=(10,5*len(QS_it)))
  if len(QS_it):
      ax =np.array([ax[:]])
  for i, qit in enumerate(QS_it):
      params = np.loadtxt(os.path.join(".", filename))[i*qRun:(i+1)*qRun]
  
      fontsize=24
  
      inres = params[:,12].astype("bool")
      #hattheta1s = params[:,10]
      #hattheta1s_std = params[:,11]
      #inres = np.logical_and(hattheta1s_std < 1.0, np.abs(np.sin(hattheta1s)) < 0.5)
  
      totmass = params[:,0][inres]
      qs = params[:,1][inres]
      e1ds = params[:,2][inres]
      e2ds = params[:,3][inres]
  
      e1s = params[:,4][inres]
      e1s_std = params[:,5][inres]
      e2s = params[:,6][inres]
      e2s_std = params[:,7][inres]
      Dpoms = params[:,8][inres]
      print(Dpoms)
      Dpoms_std = params[:,9][inres]
      hattheta1s = params[:,10][inres]
      hattheta1s_std = params[:,11][inres]
  
      aligned = np.abs(Dpoms) < 0.5
      perp = np.abs(np.abs(Dpoms)-pi/2) < 0.5
      antialigned = np.logical_not(np.logical_or(aligned,perp))
      print(aligned, perp, antialigned)
  
      cs = ax[i,0].scatter(e1ds[aligned], e2ds[aligned],  s=75, facecolors='k', edgecolors='k', label=r"$\varpi$-aligned")
      cs = ax[i,0].scatter(e1ds[antialigned], e2ds[antialigned],  s=75, facecolors='none', edgecolors='k', label=r"$\varpi$-anti-aligned")
      cs = ax[i,0].scatter(e1ds[perp], e2ds[perp],  s=75, facecolors='r', edgecolors='r', label=r"$\varpi$-perpendicular")
      ax[i,0].legend(bbox_to_anchor=(2.5, 1.25), fancybox=True, shadow=True,ncol=3)
  
      cs = ax[i,1].errorbar(e1s[aligned], e2s[aligned], xerr=e1s_std[aligned], yerr=e2s_std[aligned], fmt='o', ms=7.5, markerfacecolor='k', markeredgecolor='k', c="k")
      cs = ax[i,1].errorbar(e1s[antialigned], e2s[antialigned], xerr=e1s_std[antialigned], yerr=e2s_std[antialigned], ms=7.5, fmt='o', markerfacecolor='none', markeredgecolor='k',c="k")
      cs = ax[i,1].errorbar(e1s[perp], e2s[perp], xerr=e1s_std[perp], yerr=e2s_std[perp], ms=7.5, fmt='o', markerfacecolor='r', markeredgecolor='r',c="r")
      #cb = fig.colorbar(cs, ax=ax[i,1])
  
      #cb.ax.tick_params(labelsize=fontsize)
      #cb.set_label(r"$\hat{R}$", rotation=270, fontsize=fontsize, labelpad=60)
  
      ax[i,0].set_xlabel(r"$e_{1,d}$",fontsize=fontsize)
      ax[i,0].set_ylabel(r"$e_{2,d}$",fontsize=fontsize)
  
      ax[i,1].set_xlabel(r"$e_{1}$ final",fontsize=fontsize)
      ax[i,1].set_ylabel(r"$e_{2}$ final",fontsize=fontsize)
  
      ax[i,1].set_xlim(0.,0.4)
      ax[i,1].set_ylim(0.,0.4)
      fig.subplots_adjust(wspace=0.4)
      #ax[i,1].set_xlim(0,0.6)
      #ax[i,1].set_ylim(0,0.3)
  
  xlin = np.linspace(0,0.5,100)
  ax[0,1].plot(xlin, xlin, "r--", label=r"$y=x$")
  
  if q > 1:
      ax[0,1].plot(xlin, q*xlin, "k--", label=r"$y=qx$")
      ax[0,1].text(0.05,0.35,r"$y=2x$")
  if q < 1:
      ax[0,1].plot(xlin, q*xlin, "k--", label=r"$y=qx$")
      ax[0,1].text(0.15,0.05,r"$y=0.5x$")
  
  ax[0,1].text(0.25,0.35,r"$y=x$",c="r")
  ax[0,0].set_ylim(-0.05, 0.25)
  ax[0,0].set_xlim(-0.05, 0.25)
  
  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
  
  os.chdir("/home/jtlaune/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(os.path.join(".",
              f"Rhat-grid-q{q}-{prefix}.png"),
              bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: 9
: [3.13122984 3.08980855 2.99904623 0.01224215]
: [False False False  True] [False False False False] [ True  True  True False]
[[file:./.ob-jupyter/b21f5da9154044364e40587577ccd6584eac33e6.png]]
:END:

** e vectors
*** in e1 ref frame
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def plotorbit(plot_iter, cuts, fig, ax):
      os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
      prefix = "inres"
      q = 2.0
      #################
      # CONFIGURATION #
      #################
      h = 0.03
      j = 2
      a0 =1.0
      qRun = 9
      Nqs = 9
      qs = np.ones(Nqs)*q
      overwrite = True
      totmass = 1.0e-4
      Tw0 = 1000
      TeRatios = sqrt(qs)
  
      ######################
      # Varying parameters #
      ######################
      E1_0 = np.ones(Nqs)*0.001
      E2_0 = np.ones(Nqs)*0.001
  
      e1ds = np.linspace(0,0.2,3)
      e2ds = np.linspace(0,0.2,3)
  
      E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
      E1DS_single = E1DS_single.flatten()
      E2DS_single = E2DS_single.flatten()
  
      E1DS = np.array([])
      E2DS = np.array([])
      for i in range(int(Nqs/qRun)):
          E1DS = np.append(E1DS, E1DS_single)
          E2DS = np.append(E2DS, E2DS_single)
      print(len(E1DS))
  
      G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
      G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = qs
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
  
      TE_FUNCS = np.zeros(Nqs)
      TE1 = Tw0/TeRatios
      TE2 = Tw0*TeRatios
      #TM1 = np.infty*np.ones(Nqs)
      TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TS = 30.*np.maximum(TE1, TE2)
      #############################################################
      # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
      # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
      #############################################################
      cutoff_frac = 1.0
      CUTOFFS = TS*cutoff_frac
      NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                        for i, qit in enumerate(QS)])
  
      DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                              in range(Nqs)])
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
      fname = os.path.join(DIRNAMES[plot_iter], NAMES[plot_iter]+".npz")
      print(fname)
      data = np.load(fname)
      teval  = data["teval"]
      print(teval[cuts[0]], teval[cuts[-1]])
      for cut_iter in cuts:
          data = np.load(fname)
          teval  = data["teval"][cut_iter]
          theta = data["thetap"][cut_iter]
          a1     = data["a1"][cut_iter]
          a2     = data["a2"][cut_iter]
          e1     = data["e1"][cut_iter]
          e2     = data["e2"][cut_iter]
          g1     = data["g1"][cut_iter]
          g2     = data["g2"][cut_iter]
          L1     = data["L1"][cut_iter]
          L2     = data["L2"][cut_iter]
          x1     = data["x1"][cut_iter]
          y1     = data["y1"][cut_iter]
          x2     = data["x2"][cut_iter]
          y2     = data["y2"][cut_iter]
  
          #xi_avg = np.average(x1[it:]-x2[it:])
          #yi_avg = np.average(y1[it:]-y2[it:])
          Dpoms = g2-g1
  
          f1 = A(a1/a2, j)
          f2 = B(a1/a2, j)
          theta1 = (theta + g1) % (2*np.pi)
          theta2 = (theta + g2) % (2*np.pi)
          hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                                e1*cos(theta1) + f2/f1*e2*cos(theta2))
  
          hatgamma1 = hattheta1s-theta
          Rhat = np.abs(f1*e1**2+f2*e2**2+f1*f2*e1*e2*cos(Dpoms))
          ehat = np.sqrt(Rhat)
  
          ######################
          # scaling relations? #
          #####################
          q = QS[0]
          mu1 = MU1[0]
          mu2 = MU2[0]
          mutilde = mu1*mu2/(mu1+mu2)
          e1 = np.abs(f1)*e1
          e2 = np.abs(f2)*e2
          #e1 = e1/mu2**(1./3)
          #e2 = e2/mu1**(1./3)
          #ehat = ehat*(mu2/mutilde/q)**(1./3)
          #ehat = ehat/(q*mutilde)**(1./3)
  
          if cut_iter == cuts[0]:
              ax.scatter(e1*cos(pi),e1*sin(pi),
                         c="k",label=r"$|f_1|\mathbf{e_1}$",zorder=2)
              ax.scatter(e2*cos(pi-Dpoms),e2*sin(pi-Dpoms),
                         c="r",label=r"$|f_2|\mathbf{e_2}$",zorder=1)
              ax.scatter(ehat*cos(pi-(g1-hatgamma1)),ehat*sin(pi-(g1-hatgamma1)),
                         c="g",label=r"$\mathbf{\hat e}$",zorder=0)
          else:
              ax.scatter(e1*cos(pi),e1*sin(pi),
                         c="k",zorder=2)
              ax.scatter(e2*cos(pi-Dpoms),e2*sin(pi-Dpoms),
                         c="r",zorder=1)
              ax.scatter(ehat*cos(pi-(g1-hatgamma1)),ehat*sin(pi-(g1-hatgamma1)),
                         c="g",zorder=0)
  
          #lambdas = np.linspace(0,2*np.pi,1000)
          #radii1 = a1*(1-e1**2)/(1-e1*cos(lambdas))
          #print(e1,e2)
          #radii2 = a2*(1-e2**2)/(1-e2*cos(lambdas-Dpoms))
          #ax.scatter(radii1*cos(lambdas), radii1*sin(lambdas), s=0.01, c="r")
          #ax.scatter(radii2*cos(lambdas), radii2*sin(lambdas), s=0.01, c="k")
      #ax.set_xlim(-1.5,1.5)
      #ax.set_ylim(-1.5,1.5)
      ax.axhline(y=0,ls="--",c="k")
      ax.axvline(x=0,ls="--",c="k")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fig, ax = plt.subplots(3,2,figsize=(10,15))
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(2,lengs, fig, ax[1,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(2,lengs, fig, ax[1,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(6,lengs, fig, ax[2,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(6,lengs, fig, ax[2,1])
  
  for axi in ax.flatten():
      axi.set_xlim(-0.25,0.2)
      axi.set_ylim(-0.2,0.25)
      axi.set_ylabel(r"$X$")
      axi.set_xlabel(r"$Y$")
  fig.subplots_adjust(wspace=0.3,hspace=0.4)
  ax[0,0].text(0.01,0.15,r"$e_{1d}=0$"+"\n"+ r"$e_{2d}=0$")
  ax[1,0].text(0.01,0.15,r"$e_{1d}=0.2$"+"\n"+ r"$e_{2d}=0$")
  ax[2,0].text(0.01,0.15,r"$e_{1d}=0$"+"\n"+ r"$e_{2d}=0.2$")
  
  ax[0,0].text(-0.17,-.17,r"$t=0-127$ orbits",c="r")
  ax[0,1].text(-0.17,-.17,r"$t=34-38,000$ orbits",c="r")
  
  ax[1,1].set_xlim(-.7,.7)
  ax[1,1].set_ylim(-.7,.7)
  ax[2,1].set_xlim(-.7,.7)
  ax[2,1].set_ylim(-.7,.7)
  
  ax[0,0].legend(loc="upper left")
  fig.suptitle(r"$\mathbf{e}$ vectors in $\mathbf{e_1}$ rest frame")
  
  #ax[1,0].arrow(0,0,-0.1,0,width=0.005,color="b",ls="--", length_includes_head=True)
  #ax[1,1].arrow(0,0,-0.1,0,width=0.005,color="b",ls="--", length_includes_head=True)
  #ax[2,0].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
  #ax[2,1].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
  fig.subplots_adjust(wspace=0.5)
  
  os.chdir("/home/jtlaune/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig("relative-geometry.png",bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.000.npz
  0.0 254.559289758123
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.000.npz
  67882.4772688328 76367.7869274369
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.200-e2d-0.000.npz
  0.0 254.559289758123
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.200-e2d-0.000.npz
  67882.4772688328 76367.7869274369
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.200.npz
  0.0 254.559289758123
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.200.npz
  67882.4772688328 76367.7869274369
#+end_example
[[file:./.ob-jupyter/bd795a13132870677e2d7f84a57acc461272c4c3.png]]
:END:
*** in e hat ref frame
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def plotorbit(plot_iter, cuts, fig, ax):
      os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
      #################
      # CONFIGURATION #
      #################
      h = 0.03
      j = 2
      a0 = 0.7
      qRun = 16
      Nqs = 16
      qs = np.ones(Nqs)*2.
      overwrite = True
      totmass = 1.0e-4
      Tw0 = 1000
      TeRatios = sqrt(qs)
  
      ######################
      # Varying parameters #
      ######################
      E1_0 = np.ones(Nqs)*0.001
      E2_0 = np.ones(Nqs)*0.001
  
      e1ds = np.linspace(0,0.3,4)
      e2ds = np.linspace(0,0.3,4)
  
      E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
      E1DS_single = E1DS_single.flatten()
      E2DS_single = E2DS_single.flatten()
  
      E1DS = np.array([])
      E2DS = np.array([])
      for i in range(int(Nqs/qRun)):
          E1DS = np.append(E1DS, E1DS_single)
          E2DS = np.append(E2DS, E2DS_single)
      print(len(E1DS))
  
      G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
      G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = qs
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
  
      TE_FUNCS = np.zeros(Nqs)
      TE1 = Tw0/TeRatios
      TE2 = Tw0*TeRatios
      #TM1 = np.infty*np.ones(Nqs)
      TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TS = 30.*np.maximum(TE1, TE2)
      #############################################################
      # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
      # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
      #############################################################
      cutoff_frac = 1.0
      CUTOFFS = TS*cutoff_frac
      ALPHA2_0 = (3/2.)**(2./3)*np.ones(Nqs) #*(0.95*(QS>=1) + 1.05*(QS<1))
      NAMES = np.array([f"e1d-{E1DS[i]:0.1f}-e2d-{E2DS[i]:0.1f}"
                        for i, qit in enumerate(QS)])
  
      DIRNAMES = np.array([f"./driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                              in range(Nqs)])
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
      fname = os.path.join(DIRNAMES[plot_iter], NAMES[plot_iter]+".npz")
      e1d = E1DS[plot_iter]
      e2d = E2DS[plot_iter]
      print(fname)
      data = np.load(fname)
      teval  = data["teval"]
      print(teval[cuts[0]], teval[cuts[-1]])
      for cut_iter in cuts:
          data = np.load(fname)
          teval  = data["teval"][cut_iter]
          theta = data["thetap"][cut_iter]
          a1     = data["a1"][cut_iter]
          a2     = data["a2"][cut_iter]
          e1     = data["e1"][cut_iter]
          e2     = data["e2"][cut_iter]
          g1     = data["g1"][cut_iter]
          g2     = data["g2"][cut_iter]
          L1     = data["L1"][cut_iter]
          L2     = data["L2"][cut_iter]
          x1     = data["x1"][cut_iter]
          y1     = data["y1"][cut_iter]
          x2     = data["x2"][cut_iter]
          y2     = data["y2"][cut_iter]
  
          #xi_avg = np.average(x1[it:]-x2[it:])
          #yi_avg = np.average(y1[it:]-y2[it:])
          Dpoms = g1-g2
  
          f1 = A(a1/a2, j)
          f2 = B(a1/a2, j)
          theta1 = (theta + g1) % (2*np.pi)
          theta2 = (theta + g2) % (2*np.pi)
          hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                                e1*cos(theta1) + f2/f1*e2*cos(theta2))
  
          hatgamma1 = hattheta1s-theta
          Rhat = np.abs(f1*e1**2+f2*e2**2+f1*f2*e1*e2*cos(Dpoms))
          ehat = np.sqrt(Rhat)
  
          ######################
          # scaling relations? #
          #####################
          #q = QS[0]
          #mu1 = MU1[0]
          #mu2 = MU2[0]
          #mutilde = mu1*mu2/(mu1+mu2)
          #e2 = e2/q**(1./3)
          ##ehat = ehat*(mu2/mutilde/q)**(1./3)
          #ehat = ehat*(mu2/mutilde)**(1./3)
  
          if cut_iter == cuts[0]:
              ax.scatter(e1*cos(g1-hatgamma1),e1*sin(g1-hatgamma1),
                         c="k",label=r"$\mathbf{e_1}$",zorder=3)
              ax.scatter(e2*cos(g2-hatgamma1),e2*sin(g2-hatgamma1),
                         c="r",label=r"$\mathbf{e_2}$",zorder=2)
              ax.scatter(ehat*cos(0),ehat*sin(0),
                         c="g",label=r"$\mathbf{\hat e}$",zorder=1)
              if e1d > 0:
                  ax.scatter(e1d*cos(g1-hatgamma1),e1d*sin(g1-hatgamma1),
                             c="b", zorder=3)
              if e2d > 0:
                  ax.scatter(e2d*cos(g2-hatgamma1),e2d*sin(g2-hatgamma1),
                             c="orange",zorder=3)
          else:
              ax.scatter(e1*cos(g1-hatgamma1),e1*sin(g1-hatgamma1),
                         c="k",zorder=3)
              ax.scatter(e1d*cos(g1-hatgamma1),e1d*sin(g1-hatgamma1),
                         c="b",zorder=3)
              ax.scatter(e2*cos(g2-hatgamma1),e2*sin(g2-hatgamma1),
                         c="r",zorder=2)
              ax.scatter(ehat*cos(0),ehat*sin(0),
                         c="g",zorder=1)
              if e1d > 0:
                  ax.scatter(e1d*cos(g1-hatgamma1),e1d*sin(g1-hatgamma1),
                             c="b", zorder=3)
              if e2d > 0:
                  ax.scatter(e2d*cos(g2-hatgamma1),e2d*sin(g2-hatgamma1),
                             c="orange",zorder=3)
  
          #lambdas = np.linspace(0,2*np.pi,1000)
          #radii1 = a1*(1-e1**2)/(1-e1*cos(lambdas))
          #print(e1,e2)
          #radii2 = a2*(1-e2**2)/(1-e2*cos(lambdas-Dpoms))
          #ax.scatter(radii1*cos(lambdas), radii1*sin(lambdas), s=0.01, c="r")
          #ax.scatter(radii2*cos(lambdas), radii2*sin(lambdas), s=0.01, c="k")
      #ax.set_xlim(-1.5,1.5)
      #ax.set_ylim(-1.5,1.5)
      ax.axhline(y=0,ls="--",c="k")
      ax.axvline(x=0,ls="--",c="k")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fig, ax = plt.subplots(3,2,figsize=(10,15))
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(1,lengs, fig, ax[1,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(1,lengs, fig, ax[1,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(8,lengs, fig, ax[2,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(8,lengs, fig, ax[2,1])
  
  for axi in ax.flatten():
      axi.set_xlim(-0.25,0.2)
      axi.set_ylim(-0.2,0.25)
      axi.set_ylabel(r"$e\sin\gamma$")
      axi.set_xlabel(r"$e\cos\gamma$")
  fig.subplots_adjust(wspace=0.3,hspace=0.4)
  ax[0,0].text(0.01,0.15,r"$e_{1d}=0$"+"\n"+ r"$e_{2d}=0$")
  ax[1,0].text(0.01,0.15,r"$e_{1d}=0.1$"+"\n"+ r"$e_{2d}=0$")
  ax[2,0].text(0.01,0.15,r"$e_{1d}=0$"+"\n"+ r"$e_{2d}=0.1$")
  
  ax[0,0].text(-0.17,-.17,r"$t=0-127$ orbits",c="r")
  ax[0,1].text(-0.17,-.17,r"$t=34-38,000$ orbits",c="r")
  
  ax[0,0].legend(loc="upper left")
  fig.suptitle(r"$\mathbf{e}$ vectors in $\mathbf{e_1}$ rest frame")
  
  #ax[1,0].arrow(0,0,-0.1,0,width=0.005,color="b",ls="--", length_includes_head=True,zorder=0)
  #ax[1,1].arrow(0,0,-0.1,0,width=0.005,color="b",ls="--", length_includes_head=True,zorder=0)
  #ax[2,0].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
  #ax[2,1].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
  
  os.chdir("/home/jtlaune/multi-planet-architecture/docs/apsidal-alignment/")
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.0.npz
  0.0 127.2796448790615
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.0.npz
  33941.2386344164 38183.89346371845
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.1-e2d-0.0.npz
  0.0 127.2796448790615
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.1-e2d-0.0.npz
  33941.2386344164 38183.89346371845
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.2.npz
  0.0 127.2796448790615
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.2.npz
  33941.2386344164 38183.89346371845
#+end_example
[[file:./.ob-jupyter/c47e3ef5373ca675026c22b952851ad793e52579.png]]
:END:
** example select by fname
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  prefix = "closeres"
  q = 0.5
  for e1d in [0., 0.1, 0.2]:
      for e2d in [0., 0.1, 0.2]:
  
          os.chdir("/home/jtlaune/Dropbox/" \
                   "multi-planet-architecture/runs/Rhat-grid/")
          dirname = (f"{prefix}-driveTe-h-0.03-mutot-1.0e-04" \
                     f"-Tw0-1000-q{q:0.1f}")
          fname = f"e1d-{e1d:0.3f}-e2d-{e2d:0.3f}"
          data = np.load(os.path.join(dirname, fname+".npz"))
          teval  = data["teval"]
          theta  = data["thetap"]
          a1     = data["a1"]
          a2     = data["a2"]
          e1     = data["e1"]
          e2     = data["e2"]
          g1     = data["g1"]
          g2     = data["g2"]
          L1     = data["L1"]
          L2     = data["L2"]
          x1     = data["x1"]
          y1     = data["y1"]
          x2     = data["x2"]
          y2     = data["y2"]
  
          alpha = a1/a2
          theta1 = (theta+g1)%(2*np.pi)
          theta2 = (theta+g2)%(2*np.pi)
          f1 = A(alpha, j)
          f2 = B(alpha, j)
          barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
          barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
          hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                                e1*cos(theta1) + f2/f1*e2*cos(theta2))
          hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  
          fontsize=24
          fig, ax = plt.subplots(4,2, figsize=(18,16))
          tscale = 1.
  
          iplt0 = np.where(teval > 9e2)[0][0]
          teval = teval[iplt0:]
  
          #iplt = np.where(teval > 5e3)[0][0]
          iplt = len(teval)
  
          ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2,
                          alpha=0.05, c="k")
          ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2,
                          alpha=0.05, c="r")
          ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
          C0 = mpl.lines.Line2D([], [], color='k', marker="o",
                                linestyle='None', markersize=10,
                                label=r'$a_1$')
          C1 = mpl.lines.Line2D([], [], color='r', marker="o",
                                linestyle='None', markersize=10,
                                label=r'$a_2$')
          ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)
  
          ax[0,1].scatter(teval[:iplt]/tscale,
                          (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05,
                          c="k")
          ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
          ax[0,1].patch.set_visible(False)
          #ax[0,1].set_ylim((1.5,1.75))
  
          ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv,
                          s=2, alpha=0.05, c="k")
          ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
          ax[1,0].set_ylim(0, 2*np.pi*deg_conv)
  
          ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv,
                          s=2, alpha=0.05, c="k")
          ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
          ax[1,1].set_ylim(0, 2*np.pi*deg_conv)
  
          ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2,
                          alpha=0.05, c="k", label=r"$e_1$")
          ax[2,0].set_ylabel(r"$e_1$", fontsize=fontsize)
  
          ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2,
                          alpha=0.05, c="k", label=r"$e_1$")
          ax[2,1].set_ylabel(r"$e_2$", fontsize=fontsize)
  
          ax[3,0].scatter(teval[:iplt]/tscale,
                          deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
          ax[3,0].set_ylim((0., 360.))
          ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)
  
  
          Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
          Dpom = Dpom - 2*pi*(Dpom>pi)
          ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2,
                          alpha=0.05, c="k")
          ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
          ax[3,1].set_ylim((-180., 180.))
          ax[3,1].axhline(y=0., c="r", ls="--", lw=3, label="$180^\circ$")
  
          fig.subplots_adjust(hspace=0.4, wspace=0.2)
  
          for axi in ax.flatten():
              axi.tick_params(which="major", labelsize=fontsize,
                              width=3, length=8, bottom=True, top=True,
                              left=True, right=True, direction="in",
                              pad=10)
              axi.tick_params(which="minor", labelsize=fontsize,
                              width=3, length=4, bottom=True, top=True,
                              left=True, right=True, direction="in",
                              pad=10)
              axi.set_xlim((teval[:iplt][0]/tscale,
                            teval[:iplt][-1]/tscale))
              axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
              axi.yaxis.set_major_locator(MaxNLocator(4))
              axi.set_xscale("log")
          if prefix == "closeres":
              initstr = r"$P_2/P_1(t=0)$=1.55 "
          elif prefix == "inres":
              initstr = r"$P_2/P_1(t=0)$=1.5 "
  
          fig.suptitle(initstr+r"$e_{1d}$="+f"{e1d:0.1f}"
                       +r" $e_{2d}$="+f"{e2d:0.1f}"
                       +r" $q=$"+f"{q:0.1f}")
          os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/" \
                   "docs/apsidal-alignment/addenda/")
          fig.savefig(dirname+"-"+fname+".png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/c9589532cb6d3e69c865717fb0f094ff710e2e3a.png]]
[[file:./.ob-jupyter/dad1995efaad3a0159b01c28ec7160b44f012b4c.png]]
[[file:./.ob-jupyter/e962a50fbf5b71c0ad341036f7280e07f144cad0.png]]
[[file:./.ob-jupyter/fdc0997977af168a2f2179e478fa9796bc5607e1.png]]
[[file:./.ob-jupyter/3c2460b282e7df3f5a9ff2fa48c0b33adcda635d.png]]
[[file:./.ob-jupyter/8e1c3517a5daaa080b60b29e91ce0b7e77e5d1bc.png]]
[[file:./.ob-jupyter/c1879a74c59aa137f4e0d7d1bb82b2688da2d282.png]]
[[file:./.ob-jupyter/dddfc2539e7aa3837842e2b5e0b2b1dba47f6429.png]]
[[file:./.ob-jupyter/ac19d668ddcdf7f6109168dde0156e53fc075db2.png]]
:END:
* apsidal alignment explanation
** S2 combined plot
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def plot_sS1S2(iplot, ax1, ax2, prefix, q):
      os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/Rhat-grid/")
      #################
      # CONFIGURATION #
      #################
      h = 0.03
      j = 2
      a0 = 1.0
      qRun = 9
      Nqs = 9
      qs = np.ones(Nqs)*q
      overwrite = True
      totmass = 1.0e-4
      Tw0 = 1000
      TeRatios = sqrt(qs)
  
      ######################
      # Varying parameters #
      ######################
      E1_0 = np.ones(Nqs)*0.001
      E2_0 = np.ones(Nqs)*0.001
  
      e1ds = np.linspace(0,0.2,3)
      e2ds = np.linspace(0,0.2,3)
  
      E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
      E1DS_single = E1DS_single.flatten()
      E2DS_single = E2DS_single.flatten()
  
      E1DS = np.array([])
      E2DS = np.array([])
      for i in range(int(Nqs/qRun)):
          E1DS = np.append(E1DS, E1DS_single)
          E2DS = np.append(E2DS, E2DS_single)
      print(len(E1DS))
  
      G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
      G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = qs
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
  
      TE_FUNCS = np.zeros(Nqs)
      TE1 = Tw0/TeRatios
      TE2 = Tw0*TeRatios
      #TM1 = np.infty*np.ones(Nqs)
      TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TS = 30.*np.maximum(TE1, TE2)
      #############################################################
      # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
      # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
      #############################################################
      cutoff_frac = 1.0
      CUTOFFS = TS*cutoff_frac
      ALPHA2_0 = (3/2.)**(2./3)*np.ones(Nqs) #*(0.95*(QS>=1) + 1.05*(QS<1))
      NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                        for i, qit in enumerate(QS)])
  
      DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                              in range(Nqs)])
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
      dirname = DIRNAMES[iplot]
      name = NAMES[iplot]+".npz"
      print(name)
      data = np.load(os.path.join(dirname, name))
      teval  = data["teval"]
      theta  = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]
  
      alpha = a1/a2
      theta1 = (theta+g1)%(2*np.pi)
      theta2 = (theta+g2)%(2*np.pi)
      f1 = A(alpha, j)
      f2 = B(alpha, j)
      barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
      barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
      hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                            e1*cos(theta1) + f2/f1*e2*cos(theta2))
      hattheta1 = hattheta1+2*pi*(hattheta1<0.)
      os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  
      q = QS[iplot]
      Dpom = g2-g1
      S2 = f1**2*e1**2*q*sqrt(alpha) - 2*f1*f2*e1*e2*cos(g1-g2) + f2**2*e2**2/q/sqrt(alpha)
      cosDpom = ((1/q/sqrt(alpha) - q*sqrt(alpha)*np.abs(f2/f1))
                 / (1-np.abs(f2/f1)))
      e1d = E1DS[iplot]
      e2d = E2DS[iplot]
      Te1 = TE1[iplot]
      Te2 = TE2[iplot]
      coeffe1 = e1**2*(e1-e1d)/Te1
      coeffe2 = e2**2*(e2-e2d)/Te2
      arg1 = (q**2*alpha*np.abs(f2/f1)+e2/e1*q*sqrt(alpha)*cos(Dpom))
      arg2 = (np.abs(f2/f1)*q*sqrt(alpha)*e1/e2*cos(Dpom)+1)
      S2dot1 = coeffe1*arg1
      S2dot2 = coeffe2*arg2
      #ax[0].set_title(r"parentheses")
      #ax[1].set_title(r"coefficients")
      #ax[2].set_title(r"derivatives of individual terms")
      #ax[3].set_title(r"derivative of S2")
      tscale = 1e3 # kyr
      ax1.scatter(teval/tscale, arg1, c="k", s=2, alpha=0.05)
      ax1.scatter(teval/tscale, arg2, c="r", s=2, alpha=0.05)
      #ax2.scatter(teval/tscale, (S2dot1+S2dot2)/S2, c="k", s=2, alpha=0.05)
      ax2.scatter(teval/tscale, S2, c="k", s=2, alpha=0.05)
      ax1.set_xlim((teval[0]/tscale, teval[-1]/tscale))
      ax2.set_xlim((teval[0]/tscale, teval[-1]/tscale))
  
      for axi in [ax1, ax2]: axi.axhline(y=0, c="k", ls="--")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fontsize=24
  fig, ax = plt.subplots(3,2,figsize=(16,12))
  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.set_xlabel(r"$t$ [kyr]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
  
  prefix = "inres"
  q = 2.0
  plot_sS1S2(0, ax[0,0], ax[0,1], prefix, q)
  plot_sS1S2(2, ax[1,0], ax[1,1], prefix, q)
  plot_sS1S2(6, ax[2,0], ax[2,1], prefix, q)
  
  ax[0,0].set_ylim((-1,1))
  ax[1,0].set_ylim((-10,20))
  ax[2,0].set_ylim((-10,10))
  
  ax[0,1].set_ylim((0,0.0005))
  ax[1,1].set_ylim((0,1.))
  ax[2,1].set_ylim((0,.2))
  #ax[1,1].set_ylim((-1e-6,1e-6))
  #ax[0,1].set_ylim((-1.5e-10,1.5e-10))
  
  fig.subplots_adjust(wspace=0.3, hspace=0.5)
  C0 = mpl.lines.Line2D([], [], color='k', marker="o", linestyle='None',
                        markersize=10, label=r"$\mathcal{S}_1$")
  C1 = mpl.lines.Line2D([], [], color='r', marker="o", linestyle='None',
                        markersize=10, label=r"$\mathcal{S}_2$")
  ax[0,0].legend(bbox_to_anchor=(0.21, 1.2),ncol=2,loc="center left", fancybox=True, shadow=True, handles=[C0, C1])
  ax[0,1].set_title(r"$S_2$", fontsize=fontsize, pad=20)
  
  for i, eds in enumerate([(0,0),(0.2,0),(0,0.2)]):
      ax[i,0].text(0.5, 0.1, r"$e_{1d}=$ "+f"{eds[0]}, " + r"$e_{2d}=$ " +f"{eds[1]}", fontsize=fontsize, transform=ax[i,0].transAxes)
  
  os.chdir("/home/jtlaune/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(f"S2-conserved-{prefix}-q{q:0.1f}.png",bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: 9
: e1d-0.000-e2d-0.000.npz
: 9
: e1d-0.200-e2d-0.000.npz
: 9
: e1d-0.000-e2d-0.200.npz
[[file:./.ob-jupyter/b22702a40a0eed34a7cc52c37f4009964b18204f.png]]
:END:

** S2 conserved quantity
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def plot_S2comps(iplot):
      os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/Rhat-grid/")
      #################
      # CONFIGURATION #
      #################
      h = 0.03
      j = 2
      a0 = 0.7
      qRun = 16
      Nqs = 16
      qs = np.ones(Nqs)*2
      overwrite = True
      totmass = 1.0e-4
      Tw0 = 1000
      TeRatios = sqrt(qs)
  
      ######################
      # Varying parameters #
      ######################
      E1_0 = np.ones(Nqs)*0.001
      E2_0 = np.ones(Nqs)*0.001
  
      e1ds = np.linspace(0,0.3,4)
      e2ds = np.linspace(0,0.3,4)
  
      E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
      E1DS_single = E1DS_single.flatten()
      E2DS_single = E2DS_single.flatten()
  
      E1DS = np.array([])
      E2DS = np.array([])
      for i in range(int(Nqs/qRun)):
          E1DS = np.append(E1DS, E1DS_single)
          E2DS = np.append(E2DS, E2DS_single)
      print(len(E1DS))
  
      G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
      G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = qs
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
  
      TE_FUNCS = np.zeros(Nqs)
      TE1 = Tw0/TeRatios
      TE2 = Tw0*TeRatios
      #TM1 = np.infty*np.ones(Nqs)
      TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TS = 30.*np.maximum(TE1, TE2)
      #############################################################
      # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
      # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
      #############################################################
      cutoff_frac = 1.0
      CUTOFFS = TS*cutoff_frac
      ALPHA2_0 = (3/2.)**(2./3)*np.ones(Nqs) #*(0.95*(QS>=1) + 1.05*(QS<1))
      NAMES = np.array([f"e1d-{E1DS[i]:0.1f}-e2d-{E2DS[i]:0.1f}"
                        for i, qit in enumerate(QS)])
  
      DIRNAMES = np.array([f"./driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                              in range(Nqs)])
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
      dirname = DIRNAMES[iplot]
      name = NAMES[iplot]+".npz"
      print(name)
      data = np.load(os.path.join(dirname, name))
      teval  = data["teval"]
      theta  = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]
  
      alpha = a1/a2
      theta1 = (theta+g1)%(2*np.pi)
      theta2 = (theta+g2)%(2*np.pi)
      f1 = A(alpha, j)
      f2 = B(alpha, j)
      barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
      barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
      hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                            e1*cos(theta1) + f2/f1*e2*cos(theta2))
      hattheta1 = hattheta1+2*pi*(hattheta1<0.)
      os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  
      q = QS[iplot]
      Dpom = g2-g1
      S2 = f1**2*e1**2*q*sqrt(alpha) - 2*f1*f2*e1*e2*cos(g1-g2) + f2**2*e2**2/q/sqrt(alpha)
      fig, ax = plt.subplots(4, figsize=(12,12))
      cosDpom = ((1/q/sqrt(alpha) - q*sqrt(alpha)*np.abs(f2/f1))
                 / (1-np.abs(f2/f1)))
      e1d = E1DS[iplot]
      e2d = E2DS[iplot]
      Te1 = TE1[iplot]
      Te2 = TE2[iplot]
      coeffe1 = e1**2*(e1-e1d)/Te1
      coeffe2 = e2**2*(e2-e2d)/Te2
      arg1 = (q**2*alpha*np.abs(f2/f1)+e2/e1*q*sqrt(alpha)*cos(Dpom))
      arg2 = (np.abs(f2/f1)*q*sqrt(alpha)*e1/e2*cos(Dpom)+1)
      S2dot1 = coeffe1*arg1
      S2dot2 = coeffe2*arg2
      ax[0].set_title(r"parentheses")
      ax[1].set_title(r"coefficients")
      ax[2].set_title(r"derivatives of individual terms")
      ax[3].set_title(r"derivative of S2")
      ax[0].plot(teval, arg1)
      ax[0].plot(teval, arg2)
      ax[0].set_ylim((-5,5))
      ax[1].plot(teval, coeffe1)
      ax[1].plot(teval, coeffe2)
      ax[2].plot(teval, S2dot1)
      ax[2].plot(teval, S2dot2)
      ax[3].plot(teval, S2)
      ax[3].axhline(y=0, ls="--", c="k")
      for axi in ax: axi.axhline(y=0, c="k", ls="--")
      fig.subplots_adjust(hspace=1)
#+END_SRC

#+RESULTS:

*** aligned
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  plot_S2comps(1)
#+END_SRC

#+RESULTS:
:RESULTS:
: 16
: e1d-0.1-e2d-0.0.npz
[[file:./.ob-jupyter/f040a6b135750e17e8e2ae9b364ff8472526a9e0.png]]
:END:

*** anti-aligned
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  plot_S2comps(0)
  #plot_S2comps(5)
#+END_SRC

#+RESULTS:
:RESULTS:
: 16
: e1d-0.0-e2d-0.0.npz
[[file:./.ob-jupyter/964818c9ec35d6cfb9109f07336ef0d7e4a1d6b3.png]]
:END:

*** perpendicular
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  plot_S2comps(8)
#+END_SRC

#+RESULTS:
:RESULTS:
: 16
: e1d-0.0-e2d-0.2.npz
[[file:./.ob-jupyter/c528e62ffb35f31614e79aa33eb228bf2549a8d5.png]]
:END:

** test particle
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  j = 2
  Pratio = 1/1.5
  alpha = (Pratio)**(2./3)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  a0 = 1
  a1 = 1
  q = np.linspace(1,10,1000)
  Sinth2pe1sq = (a1/a0)/(4*f2**2*alpha**(3./2))*(abs(f2/f1)+1)**2*np.ones(len(q))
  Soutth2pe1sq = (q/(1+q))**2*(a1/a0)/4/(f1**2+q*sqrt(alpha)*f2**2)*(q-abs(f2/f1))**2
  Soutth2pe1sq_pos = (q/(1+q))**2*(a1/a0)/4/(f1**2+q*sqrt(alpha)*f2**2)*(q+abs(f2/f1))**2
  Sinth1pe1sq = (a1/a0)/4/f1**2*(abs(f2/f1)+1)**2*np.ones(len(q))
  S1nolim = q**4/(1+q)**2*(a1/a0)/4/(f1**2+q*sqrt(alpha)*f2**2)*(abs(f2/f1)+1)**2
  plt.plot(q, Sinth2pe1sq)
  plt.plot(q, Sinth1pe1sq)
  plt.plot(q, Soutth2pe1sq)
  plt.plot(q, S1nolim)
  #plt.plot(q, Soutth2pe1sq_pos)
#+END_SRC

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7f6ec9e97460> |
[[file:./.ob-jupyter/47d599ca015b5a65111b05be14cbeabe06ce4653.png]]
:END:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  j = 2
  Pratio = 1/1.5
  alpha = (Pratio)**(2./3)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  eeq = np.linspace(0,0.1,100)
  epcrit_outer = eeq/sqrt(alpha)*np.abs(f1/f2)
  epcrit_inner = eeq*sqrt(alpha)/np.abs(f1/f2) # maybe not sure may need to check math again
  plt.plot(eeq, epcrit_outer)
  plt.plot(eeq, epcrit_inner)
  plt.xlim((0,0.1))
  plt.ylim((0,0.1))
#+END_SRC

#+RESULTS:
:RESULTS:
| 0.0 | 0.1 |
[[file:./.ob-jupyter/ef4cdc42be777d299bec462e2b8f22106ca73a44.png]]
:END:

** Rhat resonance EOM
i don't think this is right
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/compmass-Rhat/")
  
  ########################
  # eccentricity driving #
  ########################
  q = 2
  totmass = 1e-3
  Tw0 = 1000
  TeRatio = sqrt(q)
  Te1 = Tw0*TeRatio
  Te2 = Tw0/TeRatio
  filename = "./driveTe-h-0.10-Tw0-1000/e1d-0.300-e2d-0.000.npz"
  data = np.load(filename)
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  
  edrive_analytic_expr = (e1**2*Te2 + e2**2*Te1)/(e1*e2*(Te1+Te2))
  edrive_numerical_expr = cos(g2-g1)
  
  ############
  # large e0 #
  ############
  totmass = 1e-3
  Tw0 = 10000
  q = 2
  TeRatio = sqrt(q)
  Te1 = Tw0*TeRatio
  Te2 = Tw0/TeRatio
  
  filename = "./e0large-h-0.10-Tw0-10000-cut-0.30/e10-0.300-e20-0.300.npz"
  data = np.load(filename)
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  
  e0large_analytic_expr = (e1**2*Te2 + e2**2*Te1)/(e1*e2*(Te1+Te2))
  e0large_numerical_expr = cos(g2-g1)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fontsize=24
  fig, ax = plt.subplots(1,2, figsize=(12,6))
  tscale = 1.
  
  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]
  
  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)
  
  ax[0].scatter(teval[:iplt]/tscale,  edrive_analytic_expr[:iplt], s=2, alpha=0.05, c="r")
  ax[0].scatter(teval[:iplt]/tscale, edrive_numerical_expr[:iplt], s=2, alpha=0.05, c="k")
  ax[0].set_ylim((-1,10))
  
  ax[1].scatter(teval[:iplt]/tscale,  e0large_analytic_expr[:iplt], s=2, alpha=0.05, c="r")
  ax[1].scatter(teval[:iplt]/tscale, e0large_numerical_expr[:iplt], s=2, alpha=0.05, c="k")
  ax[1].set_ylim((-1,10))
  
  
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 | -1.0 | 10.0 |
 [[file:./.ob-jupyter/5c78a17283e848dd4911a9b2eaf0e0f3d6b25fe1.png]]
 :END:

* test particle results 
** tp examples
** grid
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fig, ax = plt.subplots(1, 2, figsize=(14, 6))
  j = 2
  Pratio = 1/1.5
  alpha = (Pratio)**(2./3)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  eeq = np.linspace(0,0.1,100)
  epcrit_outer = eeq/sqrt(alpha)*np.abs(f1/f2)
  epcrit_inner = eeq*sqrt(alpha)/np.abs(f1/f2) # maybe not sure may need to check math again
  #ax[0].plot(eeq, epcrit_inner,label="inner TP")
  #ax[0].plot(eeq, epcrit_outer,label="outer TP")
  #ax[1].plot(eeq, epcrit_inner,label="inner TP")
  #ax[1].plot(eeq, epcrit_outer,label="outer TP")
  
  topdir = "/home/jtlaune/multi-planet-architecture/"
  imagename = "tp-galign-grid.png"
  rundirs = ["external-grid-1e-3-long", "internal-grid-relmup-long"]
  filenames = [
      os.path.join(topdir, "runs/tp", rundir, "behaviors.txt") for rundir in rundirs
  ]
  
  for iax, filename in enumerate(filenames):
      #################
      # External Case #
      #################
      galigns = np.loadtxt(filename, skiprows=1, delimiter=",")
      ep = galigns[:, 0]
      eeq = galigns[:, 1]
      aligns = galigns[:, 3]
      inres = galigns[:, 4]
      mask_res = inres < 1
      mask_circ = np.logical_or((aligns > 0), mask_res)
      mask_align = np.logical_or((aligns < 1), mask_res)
  
      ep_circ = np.ma.masked_array(ep, mask=mask_circ)
      ep_align = np.ma.masked_array(ep, mask=mask_align)
  
      eeq_circ = np.ma.masked_array(eeq, mask=mask_circ)
      eeq_align = np.ma.masked_array(eeq, mask=mask_align)
  
      if iax == 0:
          ax[iax].scatter(ep_circ, eeq_circ, marker="o", s=120,
                          facecolors="none", edgecolors="k",
                          label=r"$\varpi$-circulating", )
          ax[iax].scatter(ep_align, eeq_align, marker="o", c="k", s=120,
                          label=r"$\varpi$-aligned" )
      else:
          ax[iax].scatter(eeq_circ, ep_circ, marker="o", s=120,
                          facecolors="none", edgecolors="k",
                          label=r"$\varpi$-circulating", )
          ax[iax].scatter(eeq_align, ep_align, marker="o", c="k", s=120,
                          label=r"$\varpi$-aligned" )
  
      ax[iax].set_xscale("log", subsx=[2, 3, 4, 5, 6, 7, 8, 9] )
      ax[iax].set_yscale("log", subsy=[2, 3, 4, 5, 6, 7, 8, 9])
  
      majorticklength = 12
      ax[iax].tick_params(axis="y", length=majorticklength,
                          which="major", direction="in", pad=10 )
      ax[iax].tick_params(axis="x", length=majorticklength,
                          which="major", direction="in", pad=10,
                          labelrotation=-90, )
      ax[iax].tick_params(length=6, which="minor", direction="in")
  
  ax[0].set_title(r"External")
  ax[0].set_xlabel(r"$e_{1}$", fontsize=32)
  ax[0].set_ylabel(r"$e_{\rm tp}$", fontsize=32)
  ax[1].set_yticklabels([])
  ax[1].set_title(r"Internal")
  ax[1].set_xlabel(r"$e_{\rm tp}$", fontsize=32)
  ax[1].set_ylabel(r"$e_{2}$", fontsize=32)
  ax[1].legend(bbox_to_anchor=(1.01, 1.03))
  fig.subplots_adjust(wspace=0.2)
  fig.savefig(imagename, bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_7454/536295056.py:54: MatplotlibDeprecationWarning: The 'subsx' parameter of __init__() has been renamed 'subs' since Matplotlib 3.3; support for the old name will be dropped two minor releases later.
:   ax[iax].set_xscale("log", subsx=[2, 3, 4, 5, 6, 7, 8, 9] )
: /tmp/ipykernel_7454/536295056.py:55: MatplotlibDeprecationWarning: The 'subsy' parameter of __init__() has been renamed 'subs' since Matplotlib 3.3; support for the old name will be dropped two minor releases later.
:   ax[iax].set_yscale("log", subsy=[2, 3, 4, 5, 6, 7, 8, 9])
[[file:./.ob-jupyter/41ebf567be3fbd94fa89c62faa9955c744eefdf6.png]]
:END:

* large initial ecc
** example
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/compmass-Rhat/")
  #################
  # CONFIGURATION #
  #################
  j = 2
  a0 = 1.0
  h = 0.1
  alpha_0 = (j/(j+1))**(2./3.)
  Nqs = 1
  qs = np.ones(Nqs)*2
  overwrite = True
  totmass = 1e-3
  #e2d = 0.0
  #e1d = 0.2
  Tw0 = 10000
  TeRatios = sqrt(qs)
  
  ######################
  # Varying parameters #
  ######################
  E1_0 = np.ones(Nqs)*0.3
  E2_0 = np.ones(Nqs)*0.3
  E1DS = np.ones(Nqs)*0.0
  E2DS = np.ones(Nqs)*0.0
  
  
  #eccs = np.array([0.1])
  #E1_0, E2_0 = np.meshgrid(eccs, eccs)
  #E1_0 = np.flip(E1_0.flatten())
  #E2_0 = np.flip(E2_0.flatten())
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  TE1 = Tw0*TeRatios
  TE2 = Tw0/TeRatios
  TM1 = TE1/3.46/HS**2*(1*(qs<1) - 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(1*(qs<1) - 1*(qs>=1))
  TS = 3.*np.maximum(TE1, TE2)
  ALPHA_0 = alpha_0*np.ones(Nqs)
  #############################################################
  # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
  # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
  #############################################################
  cutoff_frac = 0.3
  CUTOFFS = TS*cutoff_frac
  ALPHA2_0 = (3/2.)**(2./3)*1.
  NAMES = np.array([f"e10-{E1_0[i]:0.3f}-e20-{E2_0[i]:0.3f}"
                    for i, qit in enumerate(QS)])
  
  DIRNAMES = np.array([f"./e0large-h-{h:0.2f}-Tw0-{Tw0}-cut-{cutoff_frac:0.2f}" for i
                          in range(Nqs)])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
  i = -1
  name = NAMES[i]
  print(name)
  data = np.load(os.path.join(DIRNAMES[i], name+".npz"))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  
  fontsize=24
  fig, ax = plt.subplots(4,2, figsize=(18,16))
  tscale = 1.
  
  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]
  cut_t = cutoff_frac*teval[-1]
  
  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)
  
  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2, alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2, alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  ax[0,0].set_ylim((0.8, 1.5))
  C0 = mpl.lines.Line2D([], [], color='k', marker="o", linestyle='None',
                        markersize=10, label=r'$a_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o", linestyle='None',
                        markersize=10, label=r'$a_2$')
  ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)
  
  ax[0,1].scatter(teval[:iplt]/tscale, (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05, c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  #ax[0,1].set_zorder(axp.get_zorder()+1)
  ax[0,1].patch.set_visible(False)
  ax[0,1].set_ylim((1.45,1.6))
  
  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e$", fontsize=fontsize)
  ax[2,0].set_ylim(0, 0.35)
  
  ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,1].set_ylabel(r"$e$", fontsize=fontsize)
  ax[2,1].set_ylim(0, 0.35)
  
  ax[3,0].scatter(teval[:iplt]/tscale, deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
  ax[3,0].set_ylim((0., 360.))
  ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)
  
  
  Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
  Dpom = Dpom - 2*pi*(Dpom>pi)
  ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2, alpha=0.05, c="k")
  ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
  ax[3,1].set_ylim((-180., 180.))
  ax[3,1].axhline(y=0., c="r", ls="--", lw=3, label="$180^\circ$")
  #ax[3,1].legend()
  
  fig.subplots_adjust(hspace=0.4, wspace=0.2)
  
  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale, teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
      axi.axvline(x=cut_t, ls="--", c="k")
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  print(f"./e0large-h-{h:0.2f}-Tw0-{Tw0}-cut-{cutoff_frac:0.2f}.png")
  fig.savefig(f"./e0large-h-{h:0.2f}-Tw0-{Tw0}-cut-{cutoff_frac:0.2f}.png", bbox_inches="tight")
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 : e10-0.300-e20-0.300
 : ./e0large-h-0.10-Tw0-10000-cut-0.30.png
 [[file:./.ob-jupyter/5088f0b5ff5859cfe4ecea8e9f8a918985edf1c3.png]]
 :END:

* phase space paths
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fig, ax = plt.subplots(2,3,figsize=(18,12))
  j = 1
  
  filter_size = 1
  plt_skip = 250
  
  ####################
  # STANDARD EXAMPLE #
  ####################
  fname = "/home/jtlaune/multi-planet-architecture/runs/standard-compmass/standard-h-0.10-Tw0-1000/q2.00.npz"
  data = np.load(fname)
  teval  = data["teval"][::plt_skip]
  theta  = uniform_filter1d(data["thetap"], filter_size)[::plt_skip]
  a1     = uniform_filter1d(data["a1"], filter_size)[::plt_skip]
  a2     = uniform_filter1d(data["a2"], filter_size)[::plt_skip]
  e1     = uniform_filter1d(data["e1"], filter_size)[::plt_skip]     
  e2     = uniform_filter1d(data["e2"], filter_size)[::plt_skip]
  g1     = uniform_filter1d(data["g1"], filter_size)[::plt_skip]     
  g2     = uniform_filter1d(data["g2"], filter_size)[::plt_skip]
  L1     = uniform_filter1d(data["L1"], filter_size)[::plt_skip]     
  L2     = uniform_filter1d(data["L2"], filter_size)[::plt_skip]
  x1     = uniform_filter1d(data["x1"], filter_size)[::plt_skip]     
  y1     = uniform_filter1d(data["y1"], filter_size)[::plt_skip]
  x2     = uniform_filter1d(data["x2"], filter_size)[::plt_skip]     
  y2     = uniform_filter1d(data["y2"], filter_size)[::plt_skip]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  hattheta1 = pi - hattheta1
  fontsize=24
  ehat = np.sqrt(f1**2*e1**2 + f2**2*e2**2 - 2*np.abs(f1*f2)*e1*e2*cos(g1-g2))
  
  ax[0,0].scatter(e2*cos(theta2), e2*sin(theta2), c=teval)
  ax[1,0].scatter(ehat*cos(hattheta1), ehat*sin(hattheta1), c=teval)
  
  ########################
  # ECCENTRICITY DRIVING #
  ########################
  fname = "/home/jtlaune/multi-planet-architecture/runs/compmass-Rhat/driveTe-h-0.10-Tw0-1000/e1d-0.300-e2d-0.000.npz"
  data = np.load(fname)
  teval  = data["teval"][::plt_skip]
  theta  = uniform_filter1d(data["thetap"], filter_size)[::plt_skip]
  a1     = uniform_filter1d(data["a1"], filter_size)[::plt_skip]
  a2     = uniform_filter1d(data["a2"], filter_size)[::plt_skip]
  e1     = uniform_filter1d(data["e1"], filter_size)[::plt_skip]     
  e2     = uniform_filter1d(data["e2"], filter_size)[::plt_skip]
  g1     = uniform_filter1d(data["g1"], filter_size)[::plt_skip]     
  g2     = uniform_filter1d(data["g2"], filter_size)[::plt_skip]
  L1     = uniform_filter1d(data["L1"], filter_size)[::plt_skip]     
  L2     = uniform_filter1d(data["L2"], filter_size)[::plt_skip]
  x1     = uniform_filter1d(data["x1"], filter_size)[::plt_skip]     
  y1     = uniform_filter1d(data["y1"], filter_size)[::plt_skip]
  x2     = uniform_filter1d(data["x2"], filter_size)[::plt_skip]     
  y2     = uniform_filter1d(data["y2"], filter_size)[::plt_skip]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  hattheta1 = pi - hattheta1
  fontsize=24
  ehat = np.sqrt(f1**2*e1**2 + f2**2*e2**2 - 2*np.abs(f1*f2)*e1*e2*cos(g1-g2))
  
  ax[0,1].scatter(e2*cos(theta2), e2*sin(theta2), c=teval)
  ax[1,1].scatter(ehat*cos(hattheta1), ehat*sin(hattheta1), c=teval)
  
  ##############################
  # LARGE INITIAL ECCENTRICITY #
  ##############################
  fname = "/home/jtlaune/multi-planet-architecture/runs/compmass-Rhat/e0large-h-0.10-Tw0-10000-cut-0.30/e10-0.300-e20-0.300.npz"
  data = np.load(fname)
  teval  = data["teval"][::plt_skip]
  theta  = uniform_filter1d(data["thetap"], filter_size)[::plt_skip]
  a1     = uniform_filter1d(data["a1"], filter_size)[::plt_skip]
  a2     = uniform_filter1d(data["a2"], filter_size)[::plt_skip]
  e1     = uniform_filter1d(data["e1"], filter_size)[::plt_skip]     
  e2     = uniform_filter1d(data["e2"], filter_size)[::plt_skip]
  g1     = uniform_filter1d(data["g1"], filter_size)[::plt_skip]     
  g2     = uniform_filter1d(data["g2"], filter_size)[::plt_skip]
  L1     = uniform_filter1d(data["L1"], filter_size)[::plt_skip]     
  L2     = uniform_filter1d(data["L2"], filter_size)[::plt_skip]
  x1     = uniform_filter1d(data["x1"], filter_size)[::plt_skip]     
  y1     = uniform_filter1d(data["y1"], filter_size)[::plt_skip]
  x2     = uniform_filter1d(data["x2"], filter_size)[::plt_skip]     
  y2     = uniform_filter1d(data["y2"], filter_size)[::plt_skip]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  hattheta1 = pi - hattheta1
  fontsize=24
  ehat = np.sqrt(f1**2*e1**2 + f2**2*e2**2 - 2*np.abs(f1*f2)*e1*e2*cos(g1-g2))
  
  ax[0,2].scatter(e2*cos(theta2), e2*sin(theta2), c=teval)
  ax[1,2].scatter(ehat*cos(hattheta1), ehat*sin(hattheta1), c=teval)
  
  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.axhline(y=0, ls="--", c="k")
      axi.axvline(x=0, ls="--", c="k")
      axi.set_xlim((-0.3,0.3))
  ax[0,0].set_ylabel(r"$e_2\sin\theta_2$", fontsize=30)
  ax[1,0].set_ylabel(r"$\hat e\sin\hat\theta$", fontsize=30)
  for i in range(3):
      ax[0,i].set_xlabel(r"$e_2\cos\theta_2$", fontsize=30)
      ax[0,i].set_ylim((-0.2,0.2))
  for i in range(3):
      ax[1,i].set_xlabel(r"$\hat e\cos\hat\theta$", fontsize=30)
      ax[1,i].set_ylim((-0.15,0.15))
      ax[1,i].set_xlim((-0.4,0.4))
  plt.subplots_adjust(hspace=0.3)
  ax[0,0].set_title(r"Standard", fontsize=36, pad=20)
  ax[0,1].set_title(r"$e_2$-driving", fontsize=36, pad=20)
  ax[0,2].set_title(r"Large $e_0$", fontsize=36, pad=20)
  
  ax[0,0].set_xlim((-0.08,0.08))
  ax[0,0].set_ylim((-0.05,0.05))
  ax[1,0].set_ylim((-0.02,0.02))
  ax[1,1].set_xlim((-0.1,0.5))
  
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(f"phasediagsex.png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/ea4dec0b1a34b5289b1b1f00d58a954f3a23e754.png]]

