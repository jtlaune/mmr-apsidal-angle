#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  from matplotlib.ticker import MaxNLocator
  from matplotlib.ticker import ScalarFormatter
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  from plotting import *
  import importlib
  import os
  import seaborn as sns
  from scipy.ndimage import uniform_filter1d
  j = 2
  plt.rcParams.update({"font.size": 20,
                       "figure.facecolor": "white",
                       "figure.figsize": (6,6),
                       #'font.family': 'serif',
                       #"font.serif": ["DejaVu Serif"],
                       #"text.usetex": False,
                       "axes.linewidth": 3,
                       'font.family': 'lmodern',
                       'text.usetex': True,
                       'text.latex.preamble': (            # LaTeX preamble
                           r'\usepackage{lmodern}'
                           # ... more packages if needed
                       )
                       })
  # Create an array with the colors you want to use
  #colors = ["#FF0B04", "#4374B3"]# Set your custom color palette
  #sns.set_palette("dark")

  pal = sns.color_palette("colorblind").as_hex()
  blue = pal[0]
  orange = pal[3]
  palette = [blue, orange, *pal[1:2], *pal[4:]]
  print(palette)
  sns.set_palette(sns.color_palette(palette))

  # important constants
  deg_conv = 180./np.pi
#+END_SRC

#+RESULTS:
: ['#0173b2', '#d55e00', '#de8f05', '#cc78bc', '#ca9161', '#fbafe4', '#949494', '#ece133', '#56b4e9']

* example
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/Rhat-grid/")
  prefix = "inres"
  q = 2.0
  #################
  # CONFIGURATION #
  #################
  h = 0.03
  j = 2
  a0 = 1.0
  qRun = 9
  Nqs = 9
  qs = np.ones(Nqs)*q
  overwrite = True
  totmass = 1.0e-4
  Tw0 = 1000
  TeRatios = sqrt(qs)
  
  ######################
  # Varying parameters #
  ######################
  E1_0 = np.ones(Nqs)*0.001
  E2_0 = np.ones(Nqs)*0.001
  
  e1ds = np.linspace(0,0.2,3)
  e2ds = np.linspace(0,0.2,3)
  
  E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
  E1DS_single = E1DS_single.flatten()
  E2DS_single = E2DS_single.flatten()
  
  E1DS = np.array([])
  E2DS = np.array([])
  for i in range(int(Nqs/qRun)):
      E1DS = np.append(E1DS, E1DS_single)
      E2DS = np.append(E2DS, E2DS_single)
  print(len(E1DS))
  
  G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  
  TE_FUNCS = np.zeros(Nqs)
  TE1 = Tw0/TeRatios
  TE2 = Tw0*TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TS = 30.*np.maximum(TE1, TE2)
  #############################################################
  # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
  # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
  #############################################################
  cutoff_frac = 1.0
  CUTOFFS = TS*cutoff_frac
  NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                    for i, qit in enumerate(QS)])
  
  DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                          in range(Nqs)])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
  i = 2
  dirname = DIRNAMES[i]
  name = NAMES[i]+".npz"
  print(name)
  data = np.load(os.path.join(dirname, name))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  
  fontsize=24
  fig, ax = plt.subplots(4,2, figsize=(18,16))
  tscale = 1.
  
  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]
  
  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)
  
  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2, alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2, alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  ax[0,0].set_ylim((0.9, 1.7))
  C0 = mpl.lines.Line2D([], [], color='k', marker="o", linestyle='None',
                        markersize=10, label=r'$a_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o", linestyle='None',
                        markersize=10, label=r'$a_2$')
  ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)
  
  ax[0,1].scatter(teval[:iplt]/tscale, (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05, c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  ax[0,1].patch.set_visible(False)
  #ax[0,1].set_ylim((1.5,1.75))
  
  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e_1$", fontsize=fontsize)
  ax[2,0].set_ylim(0, 0.3)
  
  ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,1].set_ylabel(r"$e_2$", fontsize=fontsize)
  ax[2,1].set_ylim(0, 0.3)
  
  ax[3,0].scatter(teval[:iplt]/tscale, deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
  ax[3,0].set_ylim((0., 360.))
  ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)
  
  
  Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
  Dpom = Dpom - 2*pi*(Dpom>pi)
  ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2, alpha=0.05, c="k")
  ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
  ax[3,1].set_ylim((-180., 180.))
  ax[3,1].axhline(y=0., c="r", ls="--", lw=3, label="$180^\circ$")
  #ax[3,1].legend()
  
  fig.subplots_adjust(hspace=0.4, wspace=0.2)
  
  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale, teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
  
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  figname = f"{prefix}-driving-example-h-{h}-Tw0-{int(Tw0)}-q{q}.png"
  print(figname)
  fig.savefig(figname, bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: 9
: e1d-0.200-e2d-0.000.npz
: inres-driving-example-h-0.03-Tw0-1000-q2.0.png
[[file:./.ob-jupyter/b09cca685ebc99d519608c6250cb2b26b58c5f8d.png]]
:END:
* perp example
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/Rhat-grid/")
  prefix="inres"
  #################
  # CONFIGURATION #
  #################
  h = 0.03
  j = 2
  a0 = 1.0
  qRun = 9
  Nqs = 9
  qs = np.ones(Nqs)*2
  overwrite = True
  totmass = 1.0e-4
  Tw0 = 1000
  TeRatios = sqrt(qs)
  
  ######################
  # Varying parameters #
  ######################
  E1_0 = np.ones(Nqs)*0.001
  E2_0 = np.ones(Nqs)*0.001
  
  e1ds = np.linspace(0,0.2,3)
  e2ds = np.linspace(0,0.2,3)
  
  E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
  E1DS_single = E1DS_single.flatten()
  E2DS_single = E2DS_single.flatten()
  
  E1DS = np.array([])
  E2DS = np.array([])
  for i in range(int(Nqs/qRun)):
      E1DS = np.append(E1DS, E1DS_single)
      E2DS = np.append(E2DS, E2DS_single)
  print(len(E1DS))
  
  G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  
  TE_FUNCS = np.zeros(Nqs)
  TE1 = Tw0/TeRatios
  TE2 = Tw0*TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TS = 30.*np.maximum(TE1, TE2)
  #############################################################
  # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
  # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
  #############################################################
  cutoff_frac = 1.0
  CUTOFFS = TS*cutoff_frac
  NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                    for i, qit in enumerate(QS)])
  
  DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                          in range(Nqs)])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
  i = 6
  dirname = DIRNAMES[i]
  name = NAMES[i]+".npz"
  print(name)
  data = np.load(os.path.join(dirname, name))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)
  
  fontsize=24
  fig, ax = plt.subplots(4,2, figsize=(18,16))
  tscale = 1.
  
  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]
  
  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)
  
  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2, alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2, alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  ax[0,0].set_ylim((0.9, 1.7))
  C0 = mpl.lines.Line2D([], [], color='k', marker="o", linestyle='None',
                        markersize=10, label=r'$a_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o", linestyle='None',
                        markersize=10, label=r'$a_2$')
  ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)
  
  ax[0,1].scatter(teval[:iplt]/tscale, (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05, c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  ax[0,1].patch.set_visible(False)
  #ax[0,1].set_ylim((1.5,1.75))
  
  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv, s=2, alpha=0.05, c="k")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)
  
  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e_1$", fontsize=fontsize)
  ax[2,0].set_ylim(0, 0.4)
  
  ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2, alpha=0.05, c="k", label=r"$e_1$")
  ax[2,1].set_ylabel(r"$e_2$", fontsize=fontsize)
  ax[2,1].set_ylim(0, 0.4)
  
  ax[3,0].scatter(teval[:iplt]/tscale, deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
  ax[3,0].set_ylim((0., 360.))
  ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)
  
  
  Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
  Dpom = Dpom - 2*pi*(Dpom>pi)
  ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2, alpha=0.05, c="k")
  ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
  ax[3,1].set_ylim((-180., 180.))
  ax[3,1].axhline(y=90., c="r", ls="--", lw=3, label="$180^\circ$")
  #ax[3,1].legend()
  
  fig.subplots_adjust(hspace=0.4, wspace=0.2)
  
  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale, teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
  
  
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/docs/apsidal-alignment/")
  filename = f"{prefix}-driving-perpendicular-example-h-{h}-Tw0-{int(Tw0)}-q{q:0.1f}.png"
  fig.savefig(filename, bbox_inches="tight")
  print(filename)
#+END_SRC

#+RESULTS:
:RESULTS:
: 9
: e1d-0.000-e2d-0.200.npz
: inres-driving-perpendicular-example-h-0.03-Tw0-1000-q2.0.png
[[file:./.ob-jupyter/9f4c810986f50bffff720d7ed5ef5a5902afe194.png]]
:END:
* grid
** single example
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  prefix = "inres"
  q = 2.0

  os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
  #################
  # CONFIGURATION #
  #################
  h = 0.03
  j = 2
  a0 = 0.7
  qRun = 9
  Nqs = 9
  qs = np.ones(Nqs)*q
  overwrite = True
  totmass = 1.0e-4
  Tw0 = 1000
  TeRatios = sqrt(qs)

  #####################
  # Varying parameters #
  ######################
  E1_0 = np.ones(Nqs)*0.001
  E2_0 = np.ones(Nqs)*0.001

  e1ds = np.linspace(0,0.2,3)
  e2ds = np.linspace(0,0.2,3)

  E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
  E1DS_single = E1DS_single.flatten()
  E2DS_single = E2DS_single.flatten()

  E1DS = np.array([])
  E2DS = np.array([])
  for i in range(int(Nqs/qRun)):
      E1DS = np.append(E1DS, E1DS_single)
      E2DS = np.append(E2DS, E2DS_single)
  print(len(E1DS))

  G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])

  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2

  TE_FUNCS = np.zeros(Nqs)
  TE1 = Tw0/TeRatios
  TE2 = Tw0*TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TS = 30.*np.maximum(TE1, TE2)
  #############################################################
  # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
  # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
  #############################################################
  cutoff_frac = 1.0
  CUTOFFS = TS*cutoff_frac
  NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                    for i, qit in enumerate(QS)])

  #ALPHA2_0 = (1.5)**(2./3)*np.ones(Nqs)
  #prefix = "inres"
  #ALPHA2_0 = (1.55)**(2./3)*np.ones(Nqs)
  DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                          in range(Nqs)])

  aligned_arr = np.zeros((Nqs, 13))
  aligned_arr[:,0] = totmass
  aligned_arr[:,1] = QS
  aligned_arr[:,2] = E1DS
  aligned_arr[:,3] = E2DS

  for i, filename in enumerate(NAMES):
      data = np.load(os.path.join(DIRNAMES[i], filename+".npz"))
      teval  = data["teval"]
      theta = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]

      it = int(len(teval)*0.9)
      #xi_avg = np.average(x1[it:]-x2[it:])
      #yi_avg = np.average(y1[it:]-y2[it:])
      Dpoms = g1[it:]-g2[it:]
      Dpom_avg = np.arctan2(np.sum(np.sin(Dpoms)), np.sum(np.cos(Dpoms)))
      Dpom_std = np.sqrt(np.sum(Dpoms-Dpom_avg)**2)/len(Dpoms)

      f1 = A(a1/a2, j)
      f2 = B(a1/a2, j)
      theta1 = theta + g1
      theta2 = theta + g2
      hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                            e1*cos(theta1) + f2/f1*e2*cos(theta2))
      hattheta1s = hattheta1s[it:]
      hattheta1_avg = np.arctan2(np.sum(np.sin(hattheta1s)), np.sum(np.cos(hattheta1s)))
      hattheta1_std = np.sqrt(np.sum(hattheta1s-hattheta1_avg)**2)/len(hattheta1s)

      inres = np.all(np.abs(hattheta1s) > 1.)

      aligned_arr[i,4] = np.average(e1[it:])
      aligned_arr[i,5] = np.std(e1[it:])
      aligned_arr[i,6] = np.average(e2[it:])
      aligned_arr[i,7] = np.std(e2[it:])
      aligned_arr[i,8] = Dpom_avg
      aligned_arr[i,9] = Dpom_std
      aligned_arr[i,10] = hattheta1_avg
      aligned_arr[i,11] = hattheta1_std
      aligned_arr[i,12] = inres
  np.savetxt(os.path.join(".", f"behaviors-{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[0]}.txt"), aligned_arr)

  os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
  h = 0.03
  totmass = 1e-4
  filename = f"behaviors-{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{q:0.1f}.txt"
  qRun = 16
  QS_it = [2.0]
  fig, ax = plt.subplots(len(QS_it)*1,2,figsize=(10,5*len(QS_it)))
  if len(QS_it):
      ax =np.array([ax[:]])
  for i, qit in enumerate(QS_it):
      params = np.loadtxt(os.path.join(".", filename))[i*qRun:(i+1)*qRun]

      fontsize=24

      inres = params[:,12].astype("bool")
      print(inres)
      #hattheta1s = params[:,10]
      #hattheta1s_std = params[:,11]
      #inres = np.logical_and(hattheta1s_std < 1.0, np.abs(np.sin(hattheta1s)) < 0.5)

      totmass = params[:,0]
      qs = params[:,1]
      e1ds = params[:,2]
      e2ds = params[:,3]

      e1s = params[:,4]
      e1s_std = params[:,5]
      e2s = params[:,6]
      e2s_std = params[:,7]
      Dpoms = params[:,8]
      print(Dpoms)
      Dpoms_std = params[:,9]
      hattheta1s = params[:,10]
      hattheta1s_std = params[:,11]

      aligned = np.logical_and(inres, np.abs(Dpoms) < 0.5)
      perp = np.logical_and(inres, np.abs(np.abs(Dpoms)-pi/2) < 0.5)
      antialigned = np.logical_and(inres, np.logical_not(np.logical_or(aligned,perp)))
      outres = np.logical_not(inres)
      print(aligned, perp, antialigned, outres)

      cs = ax[i,0].scatter(e1ds[aligned], e2ds[aligned],  s=75, facecolors='k', edgecolors='k', label=r"$\varpi$-aligned")
      cs = ax[i,0].scatter(e1ds[antialigned], e2ds[antialigned],  s=75, facecolors='none', edgecolors='k', label=r"$\varpi$-anti-aligned")
      cs = ax[i,0].scatter(e1ds[perp], e2ds[perp],  s=75, facecolors='r', edgecolors='r', label=r"$\varpi$-perpendicular")
      cs = ax[i,0].scatter(e1ds[outres], e2ds[outres],  s=75, facecolors='k', edgecolors='k', label=r"escape",marker="x")
      ax[i,0].legend(bbox_to_anchor=(0.25, 1.05), loc="lower left", fancybox=True, shadow=True,ncol=2)

      cs = ax[i,1].errorbar(e1s[aligned], e2s[aligned], xerr=e1s_std[aligned], yerr=e2s_std[aligned], fmt='o', ms=7.5, markerfacecolor='k', markeredgecolor='k', c="k")
      cs = ax[i,1].errorbar(e1s[antialigned], e2s[antialigned], xerr=e1s_std[antialigned], yerr=e2s_std[antialigned], ms=7.5, fmt='o', markerfacecolor='none', markeredgecolor='k',c="k")
      cs = ax[i,1].errorbar(e1s[perp], e2s[perp], xerr=e1s_std[perp], yerr=e2s_std[perp], ms=7.5, fmt='o', markerfacecolor='r', markeredgecolor='r',c="r")
      #cb = fig.colorbar(cs, ax=ax[i,1])

      #cb.ax.tick_params(labelsize=fontsize)
      #cb.set_label(r"$\hat{R}$", rotation=270, fontsize=fontsize, labelpad=60)

      ax[i,0].set_xlabel(r"$e_{1,d}$",fontsize=fontsize)
      ax[i,0].set_ylabel(r"$e_{2,d}$",fontsize=fontsize)

      ax[i,1].set_xlabel(r"$e_{1}$ final",fontsize=fontsize)
      ax[i,1].set_ylabel(r"$e_{2}$ final",fontsize=fontsize)

      ax[i,1].set_xlim(0.,0.4)
      ax[i,1].set_ylim(0.,0.4)
      fig.subplots_adjust(wspace=0.4)
      #ax[i,1].set_xlim(0,0.6)
      #ax[i,1].set_ylim(0,0.3)

  xlin = np.linspace(0,0.5,100)
  ax[0,1].plot(xlin, xlin, "r--", label=r"$y=x$")

  if q > 1:
      ax[0,1].plot(xlin, q*xlin, "k--", label=r"$y=qx$")
      ax[0,1].text(0.05,0.35,r"$y=2x$")
  if q < 1:
      ax[0,1].plot(xlin, q*xlin, "k--", label=r"$y=qx$")
      ax[0,1].text(0.15,0.05,r"$y=0.5x$")

  ax[0,1].text(0.25,0.35,r"$y=x$",c="r")
  ax[0,0].set_ylim(-0.05, 0.25)
  ax[0,0].set_xlim(-0.05, 0.25)

  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)

  os.chdir("/home/jtlaune/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(os.path.join(".",
              f"Rhat-grid-q{q}-{prefix}.png"),
              bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: 9
: [ True  True  True False  True  True  True  True  True]
: [-3.11633858  0.12903288  0.24126097  3.03577165  2.96476418  0.02184375
:  -1.52214447 -3.0795366   2.07259627]
: [False  True  True False False  True False False False] [False False False False False False  True False False] [ True False False False  True False False  True  True] [False False False  True False False False False False]
: /tmp/ipykernel_5181/998654211.py:171: UserWarning: You passed a edgecolor/edgecolors ('k') for an unfilled marker ('x').  Matplotlib is ignoring the edgecolor in favor of the facecolor.  This behavior may change in the future.
:   cs = ax[i,0].scatter(e1ds[outres], e2ds[outres],  s=75, facecolors='k', edgecolors='k', label=r"escape",marker="x")
[[file:./.ob-jupyter/a9f388662d01709f0858bec0b8a032d290e8482f.png]]
:END:

** vary alpha0 & q
*** gen behavior txts
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  prefixes = ["inres", "closeres", "inres", "closeres"]
  qs = [2.0, 2.0, 0.5, 0.5]
  for a in zip(prefixes, qs):
      print(a)

  for i, (prefix, q) in enumerate(zip(prefixes, qs)):
      os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
      #################
      # CONFIGURATION #
      #################
      h = 0.03
      j = 2
      a0 = 0.7
      qRun = 9
      Nqs = 9
      qs = np.ones(Nqs)*q
      overwrite = True
      totmass = 1.0e-4
      Tw0 = 1000
      TeRatios = sqrt(qs)

      #####################
      # Varying parameters #
      ######################
      E1_0 = np.ones(Nqs)*0.001
      E2_0 = np.ones(Nqs)*0.001

      e1ds = np.linspace(0,0.2,3)
      e2ds = np.linspace(0,0.2,3)

      E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
      E1DS_single = E1DS_single.flatten()
      E2DS_single = E2DS_single.flatten()

      E1DS = np.array([])
      E2DS = np.array([])
      for i in range(int(Nqs/qRun)):
          E1DS = np.append(E1DS, E1DS_single)
          E2DS = np.append(E2DS, E2DS_single)
      print(len(E1DS))

      G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
      G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])

      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = qs
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2

      TE_FUNCS = np.zeros(Nqs)
      TE1 = Tw0/TeRatios
      TE2 = Tw0*TeRatios
      #TM1 = np.infty*np.ones(Nqs)
      TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TS = 30.*np.maximum(TE1, TE2)
      #############################################################
      # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
      # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
      #############################################################
      cutoff_frac = 1.0
      CUTOFFS = TS*cutoff_frac
      NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                        for i, qit in enumerate(QS)])

      #ALPHA2_0 = (1.5)**(2./3)*np.ones(Nqs)
      #prefix = "inres"
      #ALPHA2_0 = (1.55)**(2./3)*np.ones(Nqs)
      DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                              in range(Nqs)])

      aligned_arr = np.zeros((Nqs, 13))
      aligned_arr[:,0] = totmass
      aligned_arr[:,1] = QS
      aligned_arr[:,2] = E1DS
      aligned_arr[:,3] = E2DS

      for i, filename in enumerate(NAMES):
          data = np.load(os.path.join(DIRNAMES[i], filename+".npz"))
          teval  = data["teval"]
          theta = data["thetap"]
          a1     = data["a1"]
          a2     = data["a2"]
          e1     = data["e1"]
          e2     = data["e2"]
          g1     = data["g1"]
          g2     = data["g2"]
          L1     = data["L1"]
          L2     = data["L2"]
          x1     = data["x1"]
          y1     = data["y1"]
          x2     = data["x2"]
          y2     = data["y2"]

          it = int(len(teval)*0.9)
          #xi_avg = np.average(x1[it:]-x2[it:])
          #yi_avg = np.average(y1[it:]-y2[it:])
          Dpoms = g1[it:]-g2[it:]
          Dpom_avg = np.arctan2(np.sum(np.sin(Dpoms)), np.sum(np.cos(Dpoms)))
          Dpom_std = np.sqrt(np.sum(Dpoms-Dpom_avg)**2)/len(Dpoms)

          f1 = A(a1/a2, j)
          f2 = B(a1/a2, j)
          theta1 = theta + g1
          theta2 = theta + g2
          hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                                e1*cos(theta1) + f2/f1*e2*cos(theta2))
          hattheta1s = hattheta1s[it:]
          hattheta1_avg = np.arctan2(np.sum(np.sin(hattheta1s)), np.sum(np.cos(hattheta1s)))
          hattheta1_std = np.sqrt(np.sum(hattheta1s-hattheta1_avg)**2)/len(hattheta1s)

          inres = np.all(np.abs(hattheta1s) > 1.)

          aligned_arr[i,4] = np.average(e1[it:])
          aligned_arr[i,5] = np.std(e1[it:])
          aligned_arr[i,6] = np.average(e2[it:])
          aligned_arr[i,7] = np.std(e2[it:])
          aligned_arr[i,8] = Dpom_avg
          aligned_arr[i,9] = Dpom_std
          aligned_arr[i,10] = hattheta1_avg
          aligned_arr[i,11] = hattheta1_std
          aligned_arr[i,12] = inres
      np.savetxt(os.path.join(".", f"behaviors-{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[0]}.txt"), aligned_arr)

#+END_SRC 

#+RESULTS:
: ('inres', 2.0)
: ('closeres', 2.0)
: ('inres', 0.5)
: ('closeres', 0.5)
: 9
: 9
: 9
: 9

*** plot
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  prefixes = ["inres", "closeres", "inres", "closeres"]
  qs = [2.0, 2.0, 0.5, 0.5]
  fig, ax = plt.subplots(len(qs),2,figsize=(10,5*len(qs)))
  for a in zip(prefixes, qs):
      print(a)

  for i, (prefix, q) in enumerate(zip(prefixes, qs)):
      os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
      print(prefix, q)
      h = 0.03
      totmass = 1e-4
      filename = f"behaviors-{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{q:0.1f}.txt"
      params = np.loadtxt(os.path.join(".", filename))

      fontsize=24

      inres = params[:,12].astype("bool")
      #hattheta1s = params[:,10]
      #hattheta1s_std = params[:,11]
      #inres = np.logical_and(hattheta1s_std < 1.0, np.abs(np.sin(hattheta1s)) < 0.5)

      totmass = params[:,0]
      qs = params[:,1]
      e1ds = params[:,2]
      e2ds = params[:,3]

      e1s = params[:,4]
      e1s_std = params[:,5]
      e2s = params[:,6]
      e2s_std = params[:,7]
      Dpoms = params[:,8]
      Dpoms_std = params[:,9]
      hattheta1s = params[:,10]
      hattheta1s_std = params[:,11]

      aligned = np.logical_and(inres, np.abs(Dpoms) < 0.5)
      perp = np.logical_and(inres, np.abs(np.abs(Dpoms)-pi/2) < 0.5)
      antialigned = np.logical_and(inres, np.logical_not(np.logical_or(aligned,perp)))
      outres = np.logical_not(inres)
      print(aligned, perp, antialigned, outres)

      cs = ax[i,0].scatter(e1ds[aligned], e2ds[aligned],  s=75, facecolors='k', edgecolors='k', label=r"$\varpi$-aligned")
      cs = ax[i,0].scatter(e1ds[antialigned], e2ds[antialigned],  s=75, facecolors='none', edgecolors='k', label=r"$\varpi$-anti-aligned")
      cs = ax[i,0].scatter(e1ds[perp], e2ds[perp],  s=75, facecolors='r', edgecolors='r', label=r"$\varpi$-perpendicular")
      cs = ax[i,0].scatter(e1ds[outres], e2ds[outres],  s=75, facecolors='k', edgecolors='k', label=r"escape",marker="x")
      if i==0: ax[i,0].legend(bbox_to_anchor=(0.25, 1.05), loc="lower left", fancybox=True, shadow=True,ncol=2)

      cs = ax[i,1].errorbar(e1s[aligned], e2s[aligned], xerr=e1s_std[aligned], yerr=e2s_std[aligned], fmt='o', ms=7.5, markerfacecolor='k', markeredgecolor='k', c="k")
      cs = ax[i,1].errorbar(e1s[antialigned], e2s[antialigned], xerr=e1s_std[antialigned], yerr=e2s_std[antialigned], ms=7.5, fmt='o', markerfacecolor='none', markeredgecolor='k',c="k")
      cs = ax[i,1].errorbar(e1s[perp], e2s[perp], xerr=e1s_std[perp], yerr=e2s_std[perp], ms=7.5, fmt='o', markerfacecolor='r', markeredgecolor='r',c="r")
      #cb = fig.colorbar(cs, ax=ax[i,1])

      #cb.ax.tick_params(labelsize=fontsize)
      #cb.set_label(r"$\hat{R}$", rotation=270, fontsize=fontsize, labelpad=60)

      if i==3: ax[i,0].set_xlabel(r"$e_{1,d}$",fontsize=fontsize)
      ax[i,0].set_ylabel(r"$e_{2,d}$",fontsize=fontsize)

      if i==3: ax[i,1].set_xlabel(r"$e_{1}$ final",fontsize=fontsize)
      ax[i,1].set_ylabel(r"$e_{2}$ final",fontsize=fontsize)

      ax[i,1].set_xlim(0.,0.4)
      ax[i,1].set_ylim(0.,0.4)
      #ax[i,1].set_xlim(0,0.6)
      #ax[i,1].set_ylim(0,0.3)

      xlin = np.linspace(0,0.5,100)
      ax[i,1].plot(xlin, xlin, "r--", label=r"$y=x$")

      if q > 1:
          ax[i,1].plot(xlin, q*xlin, "k--", label=r"$y=qx$")
          ax[i,1].text(0.05,0.35,r"$y=2x$")
      if q < 1:
          ax[i,1].plot(xlin, q*xlin, "k--", label=r"$y=qx$")
          ax[i,1].text(0.15,0.05,r"$y=0.5x$")

      ax[i,1].text(0.25,0.35,r"$y=x$",c="r")
      ax[i,0].set_ylim(-0.05, 0.3)
      ax[i,0].set_xlim(-0.05, 0.25)
      pref_initP = 1.5
      if prefix=="closeres": pref_initP = 1.55
      ax[i,0].text(-0.03, 0.245, r"$q=$"+f"{q:0.1f};"+r" $P_{2,0}/P_{1,0}=$"+f"{pref_initP:0.2f}", fontsize=20)

  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize, width=3, length=8,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)
      axi.tick_params(which="minor", labelsize=fontsize, width=3, length=4,
                      bottom=True, top=True, left=True, right=True,
                      direction="in", pad=10)

  os.chdir("/home/jtlaune/multi-planet-architecture/docs/apsidal-alignment/")
  fig.subplots_adjust(wspace=0.4)
  fig.savefig(os.path.join(".",
              f"Rhat-grids.png"),
              bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
  ('inres', 2.0)
  ('closeres', 2.0)
  ('inres', 0.5)
  ('closeres', 0.5)
  inres 2.0
  [False  True  True False False  True False False False] [False False False False False False  True False False] [ True False False False  True False False  True  True] [False False False  True False False False False False]
  closeres 2.0
  [False  True False False  True  True False False False] [False False False False False False False False False] [ True False False False False False False False False] [False False  True  True False False  True  True  True]
  inres 0.5
  [False False False False False False False False False] [False False False False False False False False False] [ True  True  True False  True False False False  True] [False False False  True False  True  True  True False]
  closeres 0.5
  [False False False False  True False False False False] [False False False False False False False False False] [ True  True  True False False False False False False] [False False False  True False  True  True  True  True]
  /tmp/ipykernel_5181/2903280629.py:45: UserWarning: You passed a edgecolor/edgecolors ('k') for an unfilled marker ('x').  Matplotlib is ignoring the edgecolor in favor of the facecolor.  This behavior may change in the future.
    cs = ax[i,0].scatter(e1ds[outres], e2ds[outres],  s=75, facecolors='k', edgecolors='k', label=r"escape",marker="x")
  /tmp/ipykernel_5181/2903280629.py:45: UserWarning: You passed a edgecolor/edgecolors ('k') for an unfilled marker ('x').  Matplotlib is ignoring the edgecolor in favor of the facecolor.  This behavior may change in the future.
    cs = ax[i,0].scatter(e1ds[outres], e2ds[outres],  s=75, facecolors='k', edgecolors='k', label=r"escape",marker="x")
  /tmp/ipykernel_5181/2903280629.py:45: UserWarning: You passed a edgecolor/edgecolors ('k') for an unfilled marker ('x').  Matplotlib is ignoring the edgecolor in favor of the facecolor.  This behavior may change in the future.
    cs = ax[i,0].scatter(e1ds[outres], e2ds[outres],  s=75, facecolors='k', edgecolors='k', label=r"escape",marker="x")
  /tmp/ipykernel_5181/2903280629.py:45: UserWarning: You passed a edgecolor/edgecolors ('k') for an unfilled marker ('x').  Matplotlib is ignoring the edgecolor in favor of the facecolor.  This behavior may change in the future.
    cs = ax[i,0].scatter(e1ds[outres], e2ds[outres],  s=75, facecolors='k', edgecolors='k', label=r"escape",marker="x")
#+end_example
[[file:./.ob-jupyter/fd56d39bc6be3f8d1119ca717d5529b9904edfad.png]]
:END:

* e vectors
** in e1 ref frame
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def plotorbit(plot_iter, cuts, fig, ax):
      os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
      prefix = "inres"
      q = 2.0
      #################
      # CONFIGURATION #
      #################
      h = 0.03
      j = 2
      a0 =1.0
      qRun = 9
      Nqs = 9
      qs = np.ones(Nqs)*q
      overwrite = True
      totmass = 1.0e-4
      Tw0 = 1000
      TeRatios = sqrt(qs)
  
      ######################
      # Varying parameters #
      ######################
      E1_0 = np.ones(Nqs)*0.001
      E2_0 = np.ones(Nqs)*0.001
  
      e1ds = np.linspace(0,0.2,3)
      e2ds = np.linspace(0,0.2,3)
  
      E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
      E1DS_single = E1DS_single.flatten()
      E2DS_single = E2DS_single.flatten()
  
      E1DS = np.array([])
      E2DS = np.array([])
      for i in range(int(Nqs/qRun)):
          E1DS = np.append(E1DS, E1DS_single)
          E2DS = np.append(E2DS, E2DS_single)
      print(len(E1DS))
  
      G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
      G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = qs
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
  
      TE_FUNCS = np.zeros(Nqs)
      TE1 = Tw0/TeRatios
      TE2 = Tw0*TeRatios
      #TM1 = np.infty*np.ones(Nqs)
      TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TS = 30.*np.maximum(TE1, TE2)
      #############################################################
      # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
      # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
      #############################################################
      cutoff_frac = 1.0
      CUTOFFS = TS*cutoff_frac
      NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                        for i, qit in enumerate(QS)])
  
      DIRNAMES = np.array([f"./{prefix}-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                              in range(Nqs)])
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
      fname = os.path.join(DIRNAMES[plot_iter], NAMES[plot_iter]+".npz")
      print(fname)
      data = np.load(fname)
      teval  = data["teval"]
      print(teval[cuts[0]], teval[cuts[-1]])
      for cut_iter in cuts:
          data = np.load(fname)
          teval  = data["teval"][cut_iter]
          theta = data["thetap"][cut_iter]
          a1     = data["a1"][cut_iter]
          a2     = data["a2"][cut_iter]
          e1     = data["e1"][cut_iter]
          e2     = data["e2"][cut_iter]
          g1     = data["g1"][cut_iter]
          g2     = data["g2"][cut_iter]
          L1     = data["L1"][cut_iter]
          L2     = data["L2"][cut_iter]
          x1     = data["x1"][cut_iter]
          y1     = data["y1"][cut_iter]
          x2     = data["x2"][cut_iter]
          y2     = data["y2"][cut_iter]
  
          #xi_avg = np.average(x1[it:]-x2[it:])
          #yi_avg = np.average(y1[it:]-y2[it:])
          Dpoms = g2-g1
  
          f1 = A(a1/a2, j)
          f2 = B(a1/a2, j)
          theta1 = (theta + g1) % (2*np.pi)
          theta2 = (theta + g2) % (2*np.pi)
          hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                                e1*cos(theta1) + f2/f1*e2*cos(theta2))
  
          hatgamma1 = hattheta1s-theta
          Rhat = np.abs(f1*e1**2+f2*e2**2+f1*f2*e1*e2*cos(Dpoms))
          ehat = np.sqrt(Rhat)
  
          ######################
          # scaling relations? #
          #####################
          q = QS[0]
          mu1 = MU1[0]
          mu2 = MU2[0]
          mutilde = mu1*mu2/(mu1+mu2)
          e1 = np.abs(f1)*e1
          e2 = np.abs(f2)*e2
          #e1 = e1/mu2**(1./3)
          #e2 = e2/mu1**(1./3)
          #ehat = ehat*(mu2/mutilde/q)**(1./3)
          #ehat = ehat/(q*mutilde)**(1./3)
  
          if cut_iter == cuts[0]:
              ax.scatter(e1*cos(pi),e1*sin(pi),
                         c="k",label=r"$|f_1|\mathbf{e_1}$",zorder=2)
              ax.scatter(e2*cos(pi-Dpoms),e2*sin(pi-Dpoms),
                         c="r",label=r"$|f_2|\mathbf{e_2}$",zorder=1)
              ax.scatter(ehat*cos(pi-(g1-hatgamma1)),ehat*sin(pi-(g1-hatgamma1)),
                         c="g",label=r"$\mathbf{\hat e}$",zorder=0)
          else:
              ax.scatter(e1*cos(pi),e1*sin(pi),
                         c="k",zorder=2)
              ax.scatter(e2*cos(pi-Dpoms),e2*sin(pi-Dpoms),
                         c="r",zorder=1)
              ax.scatter(ehat*cos(pi-(g1-hatgamma1)),ehat*sin(pi-(g1-hatgamma1)),
                         c="g",zorder=0)
  
          #lambdas = np.linspace(0,2*np.pi,1000)
          #radii1 = a1*(1-e1**2)/(1-e1*cos(lambdas))
          #print(e1,e2)
          #radii2 = a2*(1-e2**2)/(1-e2*cos(lambdas-Dpoms))
          #ax.scatter(radii1*cos(lambdas), radii1*sin(lambdas), s=0.01, c="r")
          #ax.scatter(radii2*cos(lambdas), radii2*sin(lambdas), s=0.01, c="k")
      #ax.set_xlim(-1.5,1.5)
      #ax.set_ylim(-1.5,1.5)
      ax.axhline(y=0,ls="--",c="k")
      ax.axvline(x=0,ls="--",c="k")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fig, ax = plt.subplots(3,2,figsize=(10,15))
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(2,lengs, fig, ax[1,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(2,lengs, fig, ax[1,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(6,lengs, fig, ax[2,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(6,lengs, fig, ax[2,1])
  
  for axi in ax.flatten():
      axi.set_xlim(-0.25,0.2)
      axi.set_ylim(-0.2,0.25)
      axi.set_ylabel(r"$X$")
      axi.set_xlabel(r"$Y$")
  fig.subplots_adjust(wspace=0.3,hspace=0.4)
  ax[0,0].text(0.01,0.15,r"$e_{1d}=0$"+"\n"+ r"$e_{2d}=0$")
  ax[1,0].text(0.01,0.15,r"$e_{1d}=0.2$"+"\n"+ r"$e_{2d}=0$")
  ax[2,0].text(0.01,0.15,r"$e_{1d}=0$"+"\n"+ r"$e_{2d}=0.2$")
  
  ax[0,0].text(-0.17,-.17,r"$t=0-127$ orbits",c="r")
  ax[0,1].text(-0.17,-.17,r"$t=34-38,000$ orbits",c="r")
  
  ax[1,1].set_xlim(-.7,.7)
  ax[1,1].set_ylim(-.7,.7)
  ax[2,1].set_xlim(-.7,.7)
  ax[2,1].set_ylim(-.7,.7)
  
  ax[0,0].legend(loc="upper left")
  fig.suptitle(r"$\mathbf{e}$ vectors in $\mathbf{e_1}$ rest frame")
  
  #ax[1,0].arrow(0,0,-0.1,0,width=0.005,color="b",ls="--", length_includes_head=True)
  #ax[1,1].arrow(0,0,-0.1,0,width=0.005,color="b",ls="--", length_includes_head=True)
  #ax[2,0].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
  #ax[2,1].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
  fig.subplots_adjust(wspace=0.5)
  
  os.chdir("/home/jtlaune/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig("relative-geometry.png",bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.000.npz
  0.0 254.559289758123
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.000.npz
  67882.4772688328 76367.7869274369
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.200-e2d-0.000.npz
  0.0 254.559289758123
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.200-e2d-0.000.npz
  67882.4772688328 76367.7869274369
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.200.npz
  0.0 254.559289758123
  9
  ./inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.200.npz
  67882.4772688328 76367.7869274369
#+end_example
[[file:./.ob-jupyter/bd795a13132870677e2d7f84a57acc461272c4c3.png]]
:END:
** in e hat ref frame
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def plotorbit(plot_iter, cuts, fig, ax):
      os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
      #################
      # CONFIGURATION #
      #################
      h = 0.03
      j = 2
      a0 = 0.7
      qRun = 16
      Nqs = 16
      qs = np.ones(Nqs)*2.
      overwrite = True
      totmass = 1.0e-4
      Tw0 = 1000
      TeRatios = sqrt(qs)
  
      ######################
      # Varying parameters #
      ######################
      E1_0 = np.ones(Nqs)*0.001
      E2_0 = np.ones(Nqs)*0.001
  
      e1ds = np.linspace(0,0.3,4)
      e2ds = np.linspace(0,0.3,4)
  
      E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
      E1DS_single = E1DS_single.flatten()
      E2DS_single = E2DS_single.flatten()
  
      E1DS = np.array([])
      E2DS = np.array([])
      for i in range(int(Nqs/qRun)):
          E1DS = np.append(E1DS, E1DS_single)
          E2DS = np.append(E2DS, E2DS_single)
      print(len(E1DS))
  
      G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
      G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = qs
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
  
      TE_FUNCS = np.zeros(Nqs)
      TE1 = Tw0/TeRatios
      TE2 = Tw0*TeRatios
      #TM1 = np.infty*np.ones(Nqs)
      TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TS = 30.*np.maximum(TE1, TE2)
      #############################################################
      # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
      # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
      #############################################################
      cutoff_frac = 1.0
      CUTOFFS = TS*cutoff_frac
      ALPHA2_0 = (3/2.)**(2./3)*np.ones(Nqs) #*(0.95*(QS>=1) + 1.05*(QS<1))
      NAMES = np.array([f"e1d-{E1DS[i]:0.1f}-e2d-{E2DS[i]:0.1f}"
                        for i, qit in enumerate(QS)])
  
      DIRNAMES = np.array([f"./driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                              in range(Nqs)])
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
      fname = os.path.join(DIRNAMES[plot_iter], NAMES[plot_iter]+".npz")
      e1d = E1DS[plot_iter]
      e2d = E2DS[plot_iter]
      print(fname)
      data = np.load(fname)
      teval  = data["teval"]
      print(teval[cuts[0]], teval[cuts[-1]])
      for cut_iter in cuts:
          data = np.load(fname)
          teval  = data["teval"][cut_iter]
          theta = data["thetap"][cut_iter]
          a1     = data["a1"][cut_iter]
          a2     = data["a2"][cut_iter]
          e1     = data["e1"][cut_iter]
          e2     = data["e2"][cut_iter]
          g1     = data["g1"][cut_iter]
          g2     = data["g2"][cut_iter]
          L1     = data["L1"][cut_iter]
          L2     = data["L2"][cut_iter]
          x1     = data["x1"][cut_iter]
          y1     = data["y1"][cut_iter]
          x2     = data["x2"][cut_iter]
          y2     = data["y2"][cut_iter]
  
          #xi_avg = np.average(x1[it:]-x2[it:])
          #yi_avg = np.average(y1[it:]-y2[it:])
          Dpoms = g1-g2
  
          f1 = A(a1/a2, j)
          f2 = B(a1/a2, j)
          theta1 = (theta + g1) % (2*np.pi)
          theta2 = (theta + g2) % (2*np.pi)
          hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                                e1*cos(theta1) + f2/f1*e2*cos(theta2))
  
          hatgamma1 = hattheta1s-theta
          Rhat = np.abs(f1*e1**2+f2*e2**2+f1*f2*e1*e2*cos(Dpoms))
          ehat = np.sqrt(Rhat)
  
          ######################
          # scaling relations? #
          #####################
          #q = QS[0]
          #mu1 = MU1[0]
          #mu2 = MU2[0]
          #mutilde = mu1*mu2/(mu1+mu2)
          #e2 = e2/q**(1./3)
          ##ehat = ehat*(mu2/mutilde/q)**(1./3)
          #ehat = ehat*(mu2/mutilde)**(1./3)
  
          if cut_iter == cuts[0]:
              ax.scatter(e1*cos(g1-hatgamma1),e1*sin(g1-hatgamma1),
                         c="k",label=r"$\mathbf{e_1}$",zorder=3)
              ax.scatter(e2*cos(g2-hatgamma1),e2*sin(g2-hatgamma1),
                         c="r",label=r"$\mathbf{e_2}$",zorder=2)
              ax.scatter(ehat*cos(0),ehat*sin(0),
                         c="g",label=r"$\mathbf{\hat e}$",zorder=1)
              if e1d > 0:
                  ax.scatter(e1d*cos(g1-hatgamma1),e1d*sin(g1-hatgamma1),
                             c="b", zorder=3)
              if e2d > 0:
                  ax.scatter(e2d*cos(g2-hatgamma1),e2d*sin(g2-hatgamma1),
                             c="orange",zorder=3)
          else:
              ax.scatter(e1*cos(g1-hatgamma1),e1*sin(g1-hatgamma1),
                         c="k",zorder=3)
              ax.scatter(e1d*cos(g1-hatgamma1),e1d*sin(g1-hatgamma1),
                         c="b",zorder=3)
              ax.scatter(e2*cos(g2-hatgamma1),e2*sin(g2-hatgamma1),
                         c="r",zorder=2)
              ax.scatter(ehat*cos(0),ehat*sin(0),
                         c="g",zorder=1)
              if e1d > 0:
                  ax.scatter(e1d*cos(g1-hatgamma1),e1d*sin(g1-hatgamma1),
                             c="b", zorder=3)
              if e2d > 0:
                  ax.scatter(e2d*cos(g2-hatgamma1),e2d*sin(g2-hatgamma1),
                             c="orange",zorder=3)
  
          #lambdas = np.linspace(0,2*np.pi,1000)
          #radii1 = a1*(1-e1**2)/(1-e1*cos(lambdas))
          #print(e1,e2)
          #radii2 = a2*(1-e2**2)/(1-e2*cos(lambdas-Dpoms))
          #ax.scatter(radii1*cos(lambdas), radii1*sin(lambdas), s=0.01, c="r")
          #ax.scatter(radii2*cos(lambdas), radii2*sin(lambdas), s=0.01, c="k")
      #ax.set_xlim(-1.5,1.5)
      #ax.set_ylim(-1.5,1.5)
      ax.axhline(y=0,ls="--",c="k")
      ax.axvline(x=0,ls="--",c="k")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fig, ax = plt.subplots(3,2,figsize=(10,15))
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(1,lengs, fig, ax[1,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(1,lengs, fig, ax[1,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(8,lengs, fig, ax[2,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(8,lengs, fig, ax[2,1])
  
  for axi in ax.flatten():
      axi.set_xlim(-0.25,0.2)
      axi.set_ylim(-0.2,0.25)
      axi.set_ylabel(r"$e\sin\gamma$")
      axi.set_xlabel(r"$e\cos\gamma$")
  fig.subplots_adjust(wspace=0.3,hspace=0.4)
  ax[0,0].text(0.01,0.15,r"$e_{1d}=0$"+"\n"+ r"$e_{2d}=0$")
  ax[1,0].text(0.01,0.15,r"$e_{1d}=0.1$"+"\n"+ r"$e_{2d}=0$")
  ax[2,0].text(0.01,0.15,r"$e_{1d}=0$"+"\n"+ r"$e_{2d}=0.1$")
  
  ax[0,0].text(-0.17,-.17,r"$t=0-127$ orbits",c="r")
  ax[0,1].text(-0.17,-.17,r"$t=34-38,000$ orbits",c="r")
  
  ax[0,0].legend(loc="upper left")
  fig.suptitle(r"$\mathbf{e}$ vectors in $\mathbf{e_1}$ rest frame")
  
  #ax[1,0].arrow(0,0,-0.1,0,width=0.005,color="b",ls="--", length_includes_head=True,zorder=0)
  #ax[1,1].arrow(0,0,-0.1,0,width=0.005,color="b",ls="--", length_includes_head=True,zorder=0)
  #ax[2,0].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
  #ax[2,1].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
  
  os.chdir("/home/jtlaune/multi-planet-architecture/docs/apsidal-alignment/")
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.0.npz
  0.0 127.2796448790615
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.0.npz
  33941.2386344164 38183.89346371845
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.1-e2d-0.0.npz
  0.0 127.2796448790615
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.1-e2d-0.0.npz
  33941.2386344164 38183.89346371845
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.2.npz
  0.0 127.2796448790615
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.2.npz
  33941.2386344164 38183.89346371845
#+end_example
[[file:./.ob-jupyter/c47e3ef5373ca675026c22b952851ad793e52579.png]]
:END:
* selected (long-) non-captures
** table of noncaptures
|-------------+-------+-------+----------+-----------------------------+----------------------|
| *run long?* | *e1d* | *e2d* | *P2/P10* | *note*                      | *long term (Te=150)* |
| *figure?*   |       |       |          |                             |                      |
|-------------+-------+-------+----------+-----------------------------+----------------------|
| *q=2*       |       |       |          |                             |                      |
|-------------+-------+-------+----------+-----------------------------+----------------------|
| [ ] [X]     |   0.0 |   0.1 |      1.5 | instability -> Dpom>0 lock  |                      |
|-------------+-------+-------+----------+-----------------------------+----------------------|
| [X] [X] [[/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/longruns-closeres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.200.png][img]] |   0.0 |   0.2 |     1.55 | repel -> Dpom>0 lock        | lock                 |
|             |   0.1 |   0.2 |     1.55 | repel -> P2/P1 grow         |                      |
| [X] [ ] [[/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/longruns-closeres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.000-e2d-0.100.png][img]] |   0.0 |   0.1 |     1.55 | instability -> Dpom>0 lock  | orbit cross          |
|             |   0.2 |   0.0 |     1.55 | did not capture             |                      |
| [X] [X] [[/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/longruns-closeres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.200-e2d-0.200.png][img]] |   0.2 |   0.2 |     1.55 | instability -> Dpom=0 lock  | repel & then mis     |
|-------------+-------+-------+----------+-----------------------------+----------------------|
| *q=0.5*     |       |       |          |                             |                      |
|-------------+-------+-------+----------+-----------------------------+----------------------|
|             |   0.0 |   0.1 |      1.5 | escape -> P2/P1 grow        |                      |
|             |   0.0 |   0.2 |      1.5 | escape -> P2/P1 grow        |                      |
|             |   0.1 |   0.2 |      1.5 | escape -> P2/P1 grow        |                      |
| [X] [X] [[/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/longruns-inres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q0.5/e1d-0.200-e2d-0.100.png][img]] |   0.2 |   0.1 |      1.5 | escape -> P2/P1 shrink      | orbit cross          |
|-------------+-------+-------+----------+-----------------------------+----------------------|
| [X] [ ] [[/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/longruns-closeres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q0.5/e1d-0.000-e2d-0.100.png][img]] |   0.0 |   0.1 |     1.55 | repel -> P2/P1 grow         | "bouncing"           |
| [X] [ ] [[/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/longruns-closeres-driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q0.5/e1d-0.000-e2d-0.200.png][img]] |   0.0 |   0.2 |     1.55 | repel -> P2/P1 grow         | "bouncing"           |
|             |   0.1 |   0.2 |     1.55 | repel -> P2/P1 grow         |                      |
|             |   0.2 |   0.1 |     1.55 | instability -> P2/P1 shrink |                      |
|             |   0.2 |   0.2 |     1.55 | instability -> Dpom=0 lock  |                      |
|-------------+-------+-------+----------+-----------------------------+----------------------|
- it appears as if "intability" runs break out when Dpom approaches
  zero during secular evolution
** 0.0 |   0.1 | q=2 1.5
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  prefix = "inres"
  q = 2.0

  e1d = 0.0
  e2d = 0.1
  fname = f"e1d-{e1d:0.3f}-e2d-{e2d:0.3f}"
  figname = f"{prefix}-q{q:0.1f}-" + fname

  os.chdir("/home/jtlaune/Dropbox/" \
           "multi-planet-architecture/runs/Rhat-grid/")
  dirname = (f"{prefix}-driveTe-h-0.03-mutot-1.0e-04" \
             f"-Tw0-1000-q{q:0.1f}")
  data = np.load(os.path.join(dirname, fname+".npz"))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]

  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)

  fontsize=24
  fig, ax = plt.subplots(4,2, figsize=(18,16))
  tscale = 1.

  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]

  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)

  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2,
                  alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2,
                  alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  C0 = mpl.lines.Line2D([], [], color='k', marker="o",
                        linestyle='None', markersize=10,
                        label=r'$a_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o",
                        linestyle='None', markersize=10,
                        label=r'$a_2$')
  ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)

  ax[0,1].scatter(teval[:iplt]/tscale,
                  (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05,
                  c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  ax[0,1].patch.set_visible(False)
  #ax[0,1].set_ylim((1.5,1.75))

  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv,
                  s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)

  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv,
                  s=2, alpha=0.05, c="k")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)

  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2,
                  alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e_1$", fontsize=fontsize)

  ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2,
                  alpha=0.05, c="k", label=r"$e_1$")
  ax[2,1].set_ylabel(r"$e_2$", fontsize=fontsize)

  ax[3,0].scatter(teval[:iplt]/tscale,
                  deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
  ax[3,0].set_ylim((0., 360.))
  ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)


  Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
  Dpom = Dpom - 2*pi*(Dpom>pi)
  ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2,
                  alpha=0.05, c="k")
  ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
  ax[3,1].set_ylim((-180., 180.))
  ax[3,1].axhline(y=0., c="r", ls="--", lw=3, label="$180^\circ$")

  fig.subplots_adjust(hspace=0.4, wspace=0.2)

  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize,
                      width=3, length=8, bottom=True, top=True,
                      left=True, right=True, direction="in",
                      pad=10)
      axi.tick_params(which="minor", labelsize=fontsize,
                      width=3, length=4, bottom=True, top=True,
                      left=True, right=True, direction="in",
                      pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale,
                    teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
  if prefix == "closeres":
      initstr = r"$P_2/P_1(t=0)$=1.55 "
  elif prefix == "inres":
      initstr = r"$P_2/P_1(t=0)$=1.5 "

  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/" \
           "docs/apsidal-alignment/addenda/")
  fig.savefig(figname+".png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/939cad9669fd859bc8883cf3b4c09885d1ee4ea1.png]]
 
** 0.0 |   0.2 | q=2 long   1.55
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  prefix = "closeres"
  q = 2.0

  e1d = 0.0
  e2d = 0.2
  fname = f"e1d-{e1d:0.3f}-e2d-{e2d:0.3f}"
  figname = f"longrun-{prefix}-q{q:0.1f}-" + fname

  os.chdir("/home/jtlaune/Dropbox/" \
           "multi-planet-architecture/runs/Rhat-grid/")
  dirname = (f"longruns-{prefix}-driveTe-h-0.03-mutot-1.0e-04" \
             f"-Tw0-1000-q{q:0.1f}")
  data = np.load(os.path.join(dirname, fname+".npz"))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]

  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)

  fontsize=24
  fig, ax = plt.subplots(4,2, figsize=(18,16))
  tscale = 1.

  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]

  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)

  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2,
                  alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2,
                  alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  C0 = mpl.lines.Line2D([], [], color='k', marker="o",
                        linestyle='None', markersize=10,
                        label=r'$a_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o",
                        linestyle='None', markersize=10,
                        label=r'$a_2$')
  ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)

  ax[0,1].scatter(teval[:iplt]/tscale,
                  (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05,
                  c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  ax[0,1].patch.set_visible(False)
  #ax[0,1].set_ylim((1.5,1.75))

  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv,
                  s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)

  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv,
                  s=2, alpha=0.05, c="k")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)

  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2,
                  alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e_1$", fontsize=fontsize)

  ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2,
                  alpha=0.05, c="k", label=r"$e_1$")
  ax[2,1].set_ylabel(r"$e_2$", fontsize=fontsize)

  ax[3,0].scatter(teval[:iplt]/tscale,
                  deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
  ax[3,0].set_ylim((0., 360.))
  ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)


  Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
  Dpom = Dpom - 2*pi*(Dpom>pi)
  ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2,
                  alpha=0.05, c="k")
  ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
  ax[3,1].set_ylim((-180., 180.))
  ax[3,1].axhline(y=0., c="r", ls="--", lw=3, label="$180^\circ$")

  fig.subplots_adjust(hspace=0.4, wspace=0.2)

  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize,
                      width=3, length=8, bottom=True, top=True,
                      left=True, right=True, direction="in",
                      pad=10)
      axi.tick_params(which="minor", labelsize=fontsize,
                      width=3, length=4, bottom=True, top=True,
                      left=True, right=True, direction="in",
                      pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale,
                    teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
  if prefix == "closeres":
      initstr = r"$P_2/P_1(t=0)$=1.55 "
  elif prefix == "inres":
      initstr = r"$P_2/P_1(t=0)$=1.5 "

  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/" \
           "docs/apsidal-alignment/addenda/")
  fig.savefig(figname+".png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/7e44324a2f290fa5c8092568f1489279889ed7a7.png]]

** 0.2 |   0.2 | q=2 long   1.55
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  prefix = "closeres"
  q = 2.0

  e1d = 0.2
  e2d = 0.2
  fname = f"e1d-{e1d:0.3f}-e2d-{e2d:0.3f}"
  figname = f"longrun-{prefix}-q{q:0.1f}-" + fname

  os.chdir("/home/jtlaune/Dropbox/" \
           "multi-planet-architecture/runs/Rhat-grid/")
  dirname = (f"longruns-{prefix}-driveTe-h-0.03-mutot-1.0e-04" \
             f"-Tw0-1000-q{q:0.1f}")
  data = np.load(os.path.join(dirname, fname+".npz"))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]

  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)

  fontsize=24
  fig, ax = plt.subplots(4,2, figsize=(18,16))
  tscale = 1.

  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]

  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)

  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2,
                  alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2,
                  alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  C0 = mpl.lines.Line2D([], [], color='k', marker="o",
                        linestyle='None', markersize=10,
                        label=r'$a_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o",
                        linestyle='None', markersize=10,
                        label=r'$a_2$')
  ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)

  ax[0,1].scatter(teval[:iplt]/tscale,
                  (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05,
                  c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  ax[0,1].patch.set_visible(False)
  #ax[0,1].set_ylim((1.5,1.75))

  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv,
                  s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)

  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv,
                  s=2, alpha=0.05, c="k")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)

  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2,
                  alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e_1$", fontsize=fontsize)

  ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2,
                  alpha=0.05, c="k", label=r"$e_1$")
  ax[2,1].set_ylabel(r"$e_2$", fontsize=fontsize)

  ax[3,0].scatter(teval[:iplt]/tscale,
                  deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
  ax[3,0].set_ylim((0., 360.))
  ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)


  Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
  Dpom = Dpom - 2*pi*(Dpom>pi)
  ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2,
                  alpha=0.05, c="k")
  ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
  ax[3,1].set_ylim((-180., 180.))
  ax[3,1].axhline(y=0., c="r", ls="--", lw=3, label="$180^\circ$")

  fig.subplots_adjust(hspace=0.4, wspace=0.2)

  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize,
                      width=3, length=8, bottom=True, top=True,
                      left=True, right=True, direction="in",
                      pad=10)
      axi.tick_params(which="minor", labelsize=fontsize,
                      width=3, length=4, bottom=True, top=True,
                      left=True, right=True, direction="in",
                      pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale,
                    teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
  if prefix == "closeres":
      initstr = r"$P_2/P_1(t=0)$=1.55 "
  elif prefix == "inres":
      initstr = r"$P_2/P_1(t=0)$=1.5 "

  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/" \
           "docs/apsidal-alignment/addenda/")
  fig.savefig(figname+".png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/29cbf8bfcf74f9c0f29575bae93302134bc8c891.png]]
 
** 0.2 |   0.1 | q=0.5 long 1.5
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  prefix = "inres"
  q = 0.5

  e1d = 0.2
  e2d = 0.1
  fname = f"e1d-{e1d:0.3f}-e2d-{e2d:0.3f}"
  figname = f"longrun-{prefix}-q{q:0.1f}-" + fname

  os.chdir("/home/jtlaune/Dropbox/" \
           "multi-planet-architecture/runs/Rhat-grid/")
  dirname = (f"longruns-{prefix}-driveTe-h-0.03-mutot-1.0e-04" \
             f"-Tw0-1000-q{q:0.1f}")
  data = np.load(os.path.join(dirname, fname+".npz"))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]

  alpha = a1/a2
  theta1 = (theta+g1)%(2*np.pi)
  theta2 = (theta+g2)%(2*np.pi)
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta1 = hattheta1+2*pi*(hattheta1<0.)

  fontsize=24
  fig, ax = plt.subplots(4,2, figsize=(18,16))
  tscale = 1.

  iplt0 = np.where(teval > 9e2)[0][0]
  teval = teval[iplt0:]

  #iplt = np.where(teval > 5e3)[0][0]
  iplt = len(teval)

  ax[0,0].scatter(teval[:iplt]/tscale, a1[:iplt], s=2,
                  alpha=0.05, c="k")
  ax[0,0].scatter(teval[:iplt]/tscale, a2[:iplt], s=2,
                  alpha=0.05, c="r")
  ax[0,0].set_ylabel(r"semimajor axis", fontsize=fontsize)
  C0 = mpl.lines.Line2D([], [], color='k', marker="o",
                        linestyle='None', markersize=10,
                        label=r'$a_1$')
  C1 = mpl.lines.Line2D([], [], color='r', marker="o",
                        linestyle='None', markersize=10,
                        label=r'$a_2$')
  ax[0,0].legend(handles=[C0, C1], loc="upper right", ncol=2)

  ax[0,1].scatter(teval[:iplt]/tscale,
                  (a2[:iplt]/a1[:iplt])**1.5, s=2, alpha=0.05,
                  c="k")
  ax[0,1].set_ylabel(r"$P_2/P_1$", fontsize=fontsize)
  ax[0,1].patch.set_visible(False)
  #ax[0,1].set_ylim((1.5,1.75))

  ax[1,0].scatter(teval[:iplt]/tscale, theta1[:iplt]*deg_conv,
                  s=2, alpha=0.05, c="k")
  ax[1,0].set_ylabel(r"$\theta_1$", fontsize=fontsize)
  ax[1,0].set_ylim(0, 2*np.pi*deg_conv)

  ax[1,1].scatter(teval[:iplt]/tscale, theta2[:iplt]*deg_conv,
                  s=2, alpha=0.05, c="k")
  ax[1,1].set_ylabel(r"$\theta_2$", fontsize=fontsize)
  ax[1,1].set_ylim(0, 2*np.pi*deg_conv)

  ax[2,0].scatter(teval[:iplt]/tscale,e1[:iplt], s=2,
                  alpha=0.05, c="k", label=r"$e_1$")
  ax[2,0].set_ylabel(r"$e_1$", fontsize=fontsize)

  ax[2,1].scatter(teval[:iplt]/tscale, e2[:iplt], s=2,
                  alpha=0.05, c="k", label=r"$e_1$")
  ax[2,1].set_ylabel(r"$e_2$", fontsize=fontsize)

  ax[3,0].scatter(teval[:iplt]/tscale,
                  deg_conv*hattheta1[:iplt], s=2, alpha=0.05,c="k")
  ax[3,0].set_ylim((0., 360.))
  ax[3,0].set_ylabel(r"$\hat\theta$", fontsize=fontsize)


  Dpom = (g2[:iplt]-g1[:iplt])%(2*pi)
  Dpom = Dpom - 2*pi*(Dpom>pi)
  ax[3,1].scatter(teval[:iplt]/tscale, Dpom*deg_conv, s=2,
                  alpha=0.05, c="k")
  ax[3,1].set_ylabel(r"$\varpi_1-\varpi_2$", fontsize=fontsize)
  ax[3,1].set_ylim((-180., 180.))
  ax[3,1].axhline(y=0., c="r", ls="--", lw=3, label="$180^\circ$")

  fig.subplots_adjust(hspace=0.4, wspace=0.2)

  for axi in ax.flatten():
      axi.tick_params(which="major", labelsize=fontsize,
                      width=3, length=8, bottom=True, top=True,
                      left=True, right=True, direction="in",
                      pad=10)
      axi.tick_params(which="minor", labelsize=fontsize,
                      width=3, length=4, bottom=True, top=True,
                      left=True, right=True, direction="in",
                      pad=10)
      axi.set_xlim((teval[:iplt][0]/tscale,
                    teval[:iplt][-1]/tscale))
      axi.set_xlabel(r"$t$ [y]", fontsize=fontsize)
      axi.yaxis.set_major_locator(MaxNLocator(4))
      axi.set_xscale("log")
  if prefix == "closeres":
      initstr = r"$P_2/P_1(t=0)$=1.55 "
  elif prefix == "inres":
      initstr = r"$P_2/P_1(t=0)$=1.5 "

  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/" \
           "docs/apsidal-alignment/addenda/")
  fig.savefig(figname+".png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/1a54b6b8709f4bb6e0922cc5341a109048cc8982.png]]
