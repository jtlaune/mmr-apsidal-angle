-*- mode:org -*-
#+TAGS: work
#+TYP_TODO: TODO(t) WAIT(w) | DONE(d)
#+STARTUP: latexpreview
#+TITLE: Calculations
* Eccentricity decay at extreme mass ratios
- e1 = 0.1, Te1,Tm1 = infty
- e2_disk = 0.01, Tm2=1e5
- T = 20*Te2
- Tested RK4(5) and RK8(9) with tolerances between 1e-12 to 1e-5
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  from plotting import *
  import importlib
  import os
  plt.rcParams.update({"font.size": 20, "figure.facecolor": "white", "figure.figsize": (10,10)})
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/test-eccdecay/")
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: ModuleNotFoundError                       Traceback (most recent call last)
: /tmp/ipykernel_7710/86795197.py in <module>
:       4 import scipy as sp
:       5 import scipy.optimize
: ----> 6 import matplotlib as mpl
:       7 import matplotlib.pyplot as plt
:       8 import sys
: 
: ModuleNotFoundError: No module named 'matplotlib'
:END:
** Plotting runs
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def plot(filename):
      j = 2.
      dirname = "."
      data = np.load(os.path.join(dirname, filename))
      teval  = data["teval"]
      theta = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]
  
      theta1 = (theta + g1) % (2 * np.pi)
      theta2 = (theta + g2) % (2 * np.pi)
      alpha = a1 / a2
      period_ratio = (alpha) ** (1.5)
      pnom = j / (j + 1)
      pdiff = period_ratio - pnom
  
      f1 = A(alpha, j)
      f2 = B(alpha, j)
      barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
      barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  
      bartheta1 = (theta + barg1) % (2*np.pi)
      bartheta2 = (theta + barg2) % (2*np.pi)
      # from the reducing rotation (Henrard et al 1986)
      hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                            e1*cos(theta1) + f2/f1*e2*cos(theta2))
      hattheta2 = np.arctan2(e2*sin(theta2) + f1/f2*e1*sin(theta1),
                             e2*cos(theta2) + f1/f2*e1*cos(theta1))
      fig, ax = plt.subplots(5, 2, figsize=(10, 22))
      fontsize = 24
  
      suptitle = ""
      tscale = 1e3
      # make a quick diagnostic plot
      plotsim(
          fig,
          ax,
          teval,
          suptitle,
          tscale,
          fontsize,
          (r"$a_1$", a1),
          (r"$|\varpi_1-\varpi_2|$", np.abs(g1-g2)),
          (r"$e_1$", e1),
          (r"$e_2$", e2),
          (r"$\theta_1$", theta1),
          (r"$\theta_2$", theta2),
          (r"$\overline{\theta}_1$", bartheta1),
          (r"$\overline{\theta}_2$", bartheta2),
          (r"$\hat{\theta}_1$", hattheta1),
          (r"$\hat{\theta}_2$", hattheta2),
          yfigupper=0.99,
         )
  
      ax[0, 0].scatter(teval / tscale, a2, s=2)
      axp = ax[0, 0].twinx()
      axp.scatter(teval/tscale, period_ratio, s=2, c="r")
      axp.set_ylabel(r"$P_1/P_2$", fontsize=fontsize)
      axp.tick_params(labelsize=fontsize)
      fig.subplots_adjust(wspace=0.6)
      return(fig, ax)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  tols = 10.**np.linspace(-12,-5, 8)
  for tol in tols:
      filename = f"tol-{tol:0.2e}-RK8.npz"
      fig, ax = plot(filename)
      fig.savefig(f"tol-{tol:0.2e}-RK8.png")
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/62be2d116cb2f18ceaa84dc495a6287d1b7de052.png]]
[[file:./.ob-jupyter/62be2d116cb2f18ceaa84dc495a6287d1b7de052.png]]
[[file:./.ob-jupyter/38ba471ea838b22a3026ef64d4784026174bf3f2.png]]
[[file:./.ob-jupyter/770e334a1becccd0cd4eb6af6cb3bdd9af8a156f.png]]
[[file:./.ob-jupyter/638b9fd3327ff8be480457c3d6b3fba46395d49f.png]]
[[file:./.ob-jupyter/890a24d6b871c174d162b6e37ae37821e2312aaf.png]]
[[file:./.ob-jupyter/0c2e14a7d44b7f6ff0ee0285dc6d77d05c739ace.png]]
[[file:./.ob-jupyter/a40570890ce22b0f56818bc6ce75219ff24a59bd.png]]
:END:

** Eccentricity decay results
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def gete1(filename):
      dirname = "."
      data = np.load(os.path.join(dirname, filename))
      teval  = data["teval"]
      e1     = data["e1"]
      return(teval, e1)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  j = 2.
  eeq2 = 0.01
  Tm2 = 1e5
  Te2 = eeq2**2*Tm2*2*(j+1)
  T = 20.*Te2
  q = 1e3
  mu1 = 1e-3
  tols = [1e-5, 1e-12]
  fig, ax = plt.subplots()
  for i, tol in enumerate(tols):
      fnRK4 = f"tol-{tol:0.2e}.npz"
      fnRK8 = f"tol-{tol:0.2e}-RK8.npz"
      tevalRK4, e1RK4 = gete1(fnRK4)
      tevalRK8, e1RK8 = gete1(fnRK8)
      ax.plot(tevalRK4/Te2, e1RK4, ls="-", c=f"C{i}", label=f"RK4(5); tol={tol:0.1e}")
      ax.plot(tevalRK8/Te2, e1RK8, ls="--", c=f"C{i}", label=f"RK8(9); tol={tol:0.1e}")
  ax.legend()
  ax.set_xlabel(r"time $(T_{e,2})$",fontsize=28)
  ax.set_ylabel("e1",fontsize=28)
  ax.tick_params(axis="both", labelsize=28)
  ax.set_title(f"q={q}; Te2={Te2}; Tm2={Tm2};\nmu1={mu1}; Te1,Tm1=$\\infty$", fontsize=28)
  fig.savefig("e1s.png", bbox_inches="tight")
  
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/e5177cf7a38aad285d696cbf4f4a1132bd4e23be.png]]

* Analytic equilibrium eccentricities
** Comparable mass equilibrium eccentricities
- analytical estimates seem to be underestimating near q~1
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  import importlib
  import os
  plt.rcParams.update({"font.size": 20, "figure.facecolor": "white", "figure.figsize": (10,10)})
  
  class solve_eqeccs:
      def __init__(self, q, totmass, j, Tm1, Tm2, Te1, Te2, secterms=True):
          # this class returns the equilibrium equations divided by mu2
          self.q = q
          self.mu2 = totmass/(1+q)
          alpha_0 = (j/(j+1))**(2./3.)
          self.alpha_0 = alpha_0
          self.alpha_2 = 1./alpha_0
          self.f1 = -A(alpha_0, j)
          self.f2 = -B(alpha_0, j)
          if secterms:
              self.C = C(alpha_0)
              self.D = D(alpha_0)
          else:
              self.C = 0.
              self.D = 0.
          self.Tm1 = Tm1
          self.Tm2 = Tm2
          self.Te1 = Te1
          self.Te2 = Te2
  
      def dote1(self, e1, e2, theta1, theta2):
          deriv = -self.mu2/self.alpha_2*(self.f1*sin(theta1) + self.D*e2*sin(theta1-theta2)) - e1/self.Te1
          return(deriv)
      def dote2(self, e1, e2, theta1, theta2):
          deriv = -self.mu2/self.alpha_2*self.q*(self.f2*sin(theta2) + self.D*e1*sin(theta2-theta1)) - e2/self.Te2
          return(deriv)
      def dotdpom(self, e1, e2, theta1, theta2):
          #deriv = self.mu2/self.alpha_2*(self.f1*cos(theta1)/(e1*sqrt(self.alpha_0))
          #         - self.q*cos(theta2)/e2
          #         + 2*self.C/sqrt(self.alpha_0)
          #         + self.D*e2/e1/sqrt(self.alpha_0)
          #         -self.q*2*self.C/sqrt(self.alpha_2)
          #         - self.q*self.D*e1/e2/sqrt(self.alpha_2))
          deriv = (self.f1*e2*cos(theta1)/(sqrt(self.alpha_0))
                   - self.q*self.f2*cos(theta2)*e1
                   + 2*self.C/sqrt(self.alpha_0)*e1*e2
                   + self.D*e2**2/sqrt(self.alpha_0)
                   -self.q*2*self.C/sqrt(self.alpha_2)*e1*e2
                   - self.q*self.D*e1**2/sqrt(self.alpha_2))
          return(deriv)
      def doteta(self, e1, e2, theta1, theta2):
          deriv = (self.q*sqrt(self.alpha_0)/(j*(self.q/self.alpha_0 + 1))
                   ,*(1./self.Tm2 - 1./self.Tm1
                     + 2*e1**2/self.Te1 - 2*e2**2/self.Te2)
                   - self.q*sqrt(self.alpha_0)*2*e1**2/self.Te1
                   - 2*e2**2/self.Te2)
          return(deriv)
      def __call__(self, vec):
          (e1, e2, theta1, theta2) = vec[:]
          e1_deriv = self.dote1(e1, e2, theta1, theta2)
          e2_deriv = self.dote2(e1, e2, theta1, theta2)
          dpom_deriv = self.dotdpom(e1, e2, theta1, theta2)
          eta_deriv =  self.doteta(e1, e2, theta1, theta2)
          deriv_arr = np.array([e1_deriv,
                                e2_deriv,
                                dpom_deriv,
                                eta_deriv])
          #print(vec, deriv_arr)
          return(deriv_arr)
  
  def get_eeqs(dir):
      NQS = 36
      QS = np.logspace(-3.,0.,NQS)
      NAMES = np.array([f"q{qit:0.2f}" for qit in QS])
      FILENAMES   = [os.path.join(dir, f"{name}.npz") for name in NAMES]
      qscatters = -1*np.ones(NQS)
      e1eqs = np.zeros(NQS)
      e2eqs = np.zeros(NQS)
      dpoms = np.zeros(NQS)
      for fi, filename in enumerate(FILENAMES):
          if os.path.exists(filename):
              data = np.load( filename)
              teval = data["teval"]
              theta = data["thetap"]
              e1    = data["e1"]
              e2    = data["e2"]
              g1    = data["g1"]
              g2    = data["g2"]
  
              it = int(0.9*len(teval))
              e1eqs[fi] = np.average(e1[it:])
              e2eqs[fi] = np.average(e2[it:])
              dpoms[fi] = np.average(np.abs(e2[it:]-e1[it:]))
              qscatters[fi] = QS[fi]
      return(e1eqs, e2eqs, dpoms, qscatters)
 #+END_SRC

#+RESULTS:
** e2d and e1d calculation
*** preamble
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  import importlib
  import os
  plt.rcParams.update({"font.size": 20, "figure.facecolor": "white", "figure.figsize": (10,10)})
  
  class solve_eqeccs:
      def __init__(self, q, totmass, j, e1d, e2d, Tm1, Tm2, Te1, Te2, secterms=True):
          self.q = q
          self.mu2 = totmass/(1+q)
          alpha_0 = (j/(j+1))**(2./3.)
          self.alpha_0 = alpha_0
          self.alpha_2 = 1./alpha_0
          self.f1 = -A(alpha_0, j)
          self.f2 = -B(alpha_0, j)
          if secterms:
              self.C = C(alpha_0)
              self.D = D(alpha_0)
          else:
              self.C = 0.
              self.D = 0.
          self.e1d = e1d
          self.e2d = e2d
          self.Tm1 = Tm1
          self.Tm2 = Tm2
          self.Te1 = Te1
          self.Te2 = Te2
  
      def dote1(self, e1, e2, theta1, theta2):
          e1d = self.e1d
          deriv = -self.mu2/self.alpha_2*(self.f1*sin(theta1) + self.D*e2*sin(theta1-theta2)) - (e1-e1d)/self.Te1
          return(deriv)
      def dote2(self, e1, e2, theta1, theta2):
          e2d = self.e2d
          deriv = -self.mu2/self.alpha_2*self.q*(self.f2*sin(theta2) + self.D*e1*sin(theta2-theta1)) - (e2-e2d)/self.Te2
          return(deriv)
      def dotdpom(self, e1, e2, theta1, theta2):
          #deriv = self.mu2/self.alpha_2*(self.f1*cos(theta1)/(e1*sqrt(self.alpha_0))
          #         - self.q*cos(theta2)/e2
          #         + 2*self.C/sqrt(self.alpha_0)
          #         + self.D*e2/e1/sqrt(self.alpha_0)
          #         -self.q*2*self.C/sqrt(self.alpha_2)
          #         - self.q*self.D*e1/e2/sqrt(self.alpha_2))
          deriv = (self.f1*e2*cos(theta1)/(sqrt(self.alpha_0))
                   - self.q*self.f2*cos(theta2)*e1
                   + 2*self.C/sqrt(self.alpha_0)*e1*e2
                   + self.D*e2**2/sqrt(self.alpha_0)
                   -self.q*2*self.C/sqrt(self.alpha_2)*e1*e2
                   - self.q*self.D*e1**2/sqrt(self.alpha_2))
          return(deriv)
      def doteta(self, e1, e2, theta1, theta2):
          e1d = self.e1d
          e2d = self.e2d
          deriv = (self.q*sqrt(self.alpha_0)/(j*(self.q/self.alpha_0 + 1))
                   ,*(1./self.Tm2 - 1./self.Tm1
                     + 2*(e1)**2/self.Te1 - 2*(e2)**2/self.Te2)
                   - self.q*sqrt(self.alpha_0)*2*(e1-e1d)*e1/self.Te1
                   - 2*(e2-e2d)*e2/self.Te2)
          return(deriv)
      def __call__(self, vec):
          (e1, e2, theta1, theta2) = vec[:]
          e1_deriv = self.dote1(e1, e2, theta1, theta2)
          e2_deriv = self.dote2(e1, e2, theta1, theta2)
          dpom_deriv = self.dotdpom(e1, e2, theta1, theta2)
          eta_deriv =  self.doteta(e1, e2, theta1, theta2)
          deriv_arr = np.array([e1_deriv,
                                e2_deriv,
                                dpom_deriv,
                                eta_deriv])
          #print(vec, deriv_arr)
          return(deriv_arr)
  
  def calc_eeqs(h, qs, totmass, j, e1d, e2d, Tm1s, Tm2s, Te1s, Te2s, secterms=True):
      e1s = np.zeros(Nqs)
      e2s = np.zeros(Nqs)
      theta1s = np.zeros(Nqs)
      theta2s = np.zeros(Nqs)
  
      for iq, q in enumerate(qs):
          Te1 = 2*pi*Te1s[iq]
          Te2 = 2*pi*Te2s[iq]
          Tm1 = 2*pi*Tm1s[iq]
          Tm2 = 2*pi*Tm2s[iq]
          #if q <= 1:
          #    Te2d = TW0*2*np.pi
          #    Te1d = Te2d/q/alpha_0**0.5
  
          #    Tm1 = Te1d/2.7/h**2
          #    Tm2 = Te2d/2.7/h**2
          #else:
          #    Te1d = TW0*2*np.pi
          #    Te2d = Te1d*q*alpha_0**0.5
  
          #    Tm1 = Te2d/2.7/h**2
          #    Tm2 = Te1d/2.7/h**2
  
          if q > e1d:
              x0 = (0.1, h, pi, 0.)
          elif q > 1.:
              x0 = (0.01, 0.07, pi, 0.)
          else:
              x0 = (0.5, 0.01, pi, 0.)
          mfunc = solve_eqeccs(q, totmass, j, e1d, e2d, Tm1, Tm2, Te1, Te2, secterms=secterms)
          sol = scipy.optimize.root(mfunc, x0, options={"diag":np.ones(4)*totmass, "maxfev":int(5e6)})
          x = sol.x
          e1 = x[0]
          e2 = x[1]
          theta1 = x[2]
          theta2 = x[3]
          if not sol.success:
              print(sol.message)
              e1 = -1
              e2 = -1
          e1s[iq] = e1
          e2s[iq] = e2
          theta1s[iq] = theta1
          theta2s[iq] = theta2
          #print(x, mesg, infodict["nfev"])
          #print(theta1-theta2)
      return(e1s, e2s, theta1s, theta2s)
  
  os.chdir("/home/jtlaune/multi-planet-architecture/notes/")
#+END_SRC

#+RESULTS:

*** e1d = 0.1
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  totmass = 1e-3
  h = 0.025
  j = 2
  alpha_0 = (j/(j+1))**(2./3.)
  e1d = 0.1
  e2d = 0.0
  
  Nqs = 500
  qs = np.logspace(-1., 1., Nqs)
  #qs = np.ones(Nqs)*0.1
  
  Tw0 = 1e3
  #TeRatios = np.logspace(-1,1,Nqs)
  TeRatios = np.ones(Nqs) 
  Te1s = Tw0*np.ones(Nqs)
  Te2s = Tw0*np.ones(Nqs)
  
  Tm1s = Te1s/(2.7*h*h)
  Tm2s = Tm1s*((qs*np.sqrt(alpha_0))*(qs<1.) + (qs*np.sqrt(alpha_0))**(-1)*(qs>1.))
  
  
  fig, ax = plt.subplots(1)
  
  e1s, e2s, theta1s, theta2s = calc_eeqs(h, qs, totmass, j, e1d, e2d, Tm1s, Tm2s, Te1s, Te2s, secterms=True)
  ax.plot(qs, e1s, ls="-", c="blue"  , label=(r"$e_1$"))
  ax.plot(qs, e2s, ls="-", c="orange", label=(r"$e_2$"))
  ax.set_xlabel(r"$q$")
  #ax.plot(Te2s/Te1s, e1s,   label=(r"$e_1$"))
  #ax.plot(Te2s/Te1s, e2s, label=(r"$e_2$"))
  #ax.set_xlabel(r"$T_{e1}/T_{e2}$")
  ax.set_xscale("log")
  ax.set_yscale("log")
  ax.legend()
  
  e1s, e2s, theta1s, theta2s = calc_eeqs(h, qs, totmass, j, e1d, e2d, Tm1s, Tm2s, Te1s, Te2s, secterms=False)
  #print(e2s)
  ax.plot(qs, e1s, ls="--", c="blue"  ,   label=(r"$e_1$, w/o sec"))
  ax.plot(qs, e2s, ls="--", c="orange", label=(r"$e_2$, w/o sec"))
  #ax.set_xlabel(r"$q$")
  ##ax.plot(Te2s/Te1s, e1s,   label=(r"$e_1$"))
  ##ax.plot(Te2s/Te1s, e2s, label=(r"$e_2$"))
  ##ax.set_xlabel(r"$T_{e1}/T_{e2}$")
  #ax.set_xscale("log")
  #ax.set_yscale("log")
  #ax.legend()
  
  
  fig.suptitle(f"{j}:{j+1} MMR "+r"$h=$"+f"{h:0.1e} "+r"$\mu_{\rm tot}=$"+f"{totmass:0.1e}")
  fig.tight_layout()
  
  os.chdir("/home/jtlaune/multi-planet-architecture/notes/")
 #+END_SRC
 
 #+RESULTS:
 [[file:./.ob-jupyter/257577e7e5162ac6e6a30300b46e57a92a2400fb.png]]
*** e1d=0
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  totmass = 1e-3
  h = 0.1
  j = 2
  alpha_0 = (j/(j+1))**(2./3.)
  e1d = 0.0
  e2d = 0.0
  
  Nqs = 500
  qs = np.linspace(0.5,2,Nqs)
  #qs = np.logspace(-1., 1., Nqs)
  #qs = np.ones(Nqs)*0.1
  
  Tw0 = 1e3
  #TeRatios = np.logspace(-1,1,Nqs)
  TeRatios = np.sqrt(qs)
  Te1s = Tw0*TeRatios
  Te2s = Tw0/TeRatios
  
  #Tm1s = Te1s/(2.7*h*h)
  #Tm1s = np.infty*np.ones(Nqs)
  print((1*(qs<1) - 1*(qs>1)))
  Tm1s = Te1s/3.46/h**2*(1*(qs>1) - 1*(qs<1))
  Tm2s = Te2s/3.46/h**2*(1*(qs>1) - 1*(qs<1))
  print(Te1s[0],Te2s[0],Tm1s[0], Tm2s[0])
  #Tm2s = Tm1s*((qs*np.sqrt(alpha_0))*(qs<1.) + (qs*np.sqrt(alpha_0))**(-1)*(qs>1.))
  
  
  fig, ax = plt.subplots(1)
  
  e1s, e2s, theta1s, theta2s = calc_eeqs(h, qs, totmass, j, e1d, e2d, Tm1s, Tm2s, Te1s, Te2s, secterms=True)
  ax.plot(qs, e1s, ls="-", c="blue"  , label=(r"$e_1$"))
  ax.plot(qs, e2s, ls="-", c="orange", label=(r"$e_2$"))
  ax.set_xlabel(r"$q$")
  #ax.plot(Te2s/Te1s, e1s,   label=(r"$e_1$"))
  #ax.plot(Te2s/Te1s, e2s, label=(r"$e_2$"))
  #ax.set_xlabel(r"$T_{e1}/T_{e2}$")
  #ax.set_xscale("log")
  #ax.set_yscale("log")
  ax.legend()
  
  e1s, e2s, theta1s, theta2s = calc_eeqs(h, qs, totmass, j, e1d, e2d, Tm1s, Tm2s, Te1s, Te2s, secterms=False)
  #print(e2s)
  ax.plot(qs, e1s, ls="--", c="blue"  ,   label=(r"$e_1$, w/o sec"))
  ax.plot(qs, e2s, ls="--", c="orange", label=(r"$e_2$, w/o sec"))
  #ax.set_xlabel(r"$q$")
  ##ax.plot(Te2s/Te1s, e1s,   label=(r"$e_1$"))
  ##ax.plot(Te2s/Te1s, e2s, label=(r"$e_2$"))
  ##ax.set_xlabel(r"$T_{e1}/T_{e2}$")
  #ax.set_xscale("log")
  #ax.set_yscale("log")
  #ax.legend()
  
  
  fig.suptitle(f"{j}:{j+1} MMR "+r"$h=$"+f"{h:0.1e} "+r"$\mu_{\rm tot}=$"+f"{totmass:0.1e}")
  fig.tight_layout()
  
  os.chdir("/home/jtlaune/multi-planet-architecture/notes/")
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
  [ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
    1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
    1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
    1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
    1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
    1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
    1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
   -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
  707.1067811865476 1414.2135623730949 -20436.612173021604 -40873.2243460432
#+end_example
[[file:./.ob-jupyter/34c37b68b4e45af80a9dfdd148c8c18c0fe195f0.png]]
:END:
 
* Alignment behaviors
** reproducing tp case
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/compmass/")
  #################
  # CONFIGURATION #
  #################
  j = 2
  a0 = 1.0
  h = 0.025
  alpha_0 = (j/(j+1))**(2./3.)
  Nqs = 100
  q=1000
  qs = np.ones(Nqs)*q
  overwrite = True
  totmass = 1e-3
  e2d = 0.0
  e1d = 0.0
  
  ######################
  # Varying parameters #
  ######################
  eccs = np.logspace(-2,-1,int(np.sqrt(Nqs)))
  EEQ_2, E1_0 = np.meshgrid(eccs, eccs)
  EEQ_2 = EEQ_2.flatten()
  E1_0 = E1_0.flatten()
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  TM1 = np.ones(Nqs)*np.infty
  TE1 = np.ones(Nqs)*np.infty
  TM2 = -np.ones(Nqs)*1e5
  ALPHA_0 = alpha_0*np.ones(Nqs)
  TE2 = 2.*EEQ_2**2*np.abs(TM2)*(QS*np.sqrt(ALPHA_0)+j*(QS/ALPHA_0+1))/QS/np.sqrt(ALPHA_0)
  TS = 20.*TE2
  E2_0 = np.ones(Nqs)*0.001
  E1DS = np.ones(Nqs)*e1d
  E2DS = np.ones(Nqs)*e2d
  ALPHA2_0 = (3/2.)**(2./3)*(1+EEQ_2**2+E1_0**2)
  NAMES = np.array([f"e10-{E1_0[i]:0.2f}-e2eq-{EEQ_2[i]:0.2f}"
                    for i, qit in enumerate(QS)])
  
  ################
  # WITH SECULAR #
  ################
  DIRNAMES = np.array([f"./ext-grid-q{int(QS[i])}" for i
                          in range(Nqs)])
  
  aligned_arr = np.zeros((Nqs, 6))
  aligned_arr[:,0] = totmass
  aligned_arr[:,1] = QS
  aligned_arr[:,2] = E1_0
  aligned_arr[:,3] = EEQ_2
  
  for i, filename in enumerate(NAMES):
      data = np.load(os.path.join(DIRNAMES[i], filename+".npz"))
      teval  = data["teval"]
      theta = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]
  
      it = int(len(teval)*0.9)
      align = 1*np.all((np.abs((g1[it:]-g2[it:])%(2*pi)) < 2.))
      antialign = 1*np.all((np.abs((g1[it:]-g2[it:])%(2*pi)-pi) < 1.))
      aligned_arr[i,4] = align
      aligned_arr[i,5] = antialign
  np.savetxt(os.path.join(".", f"behaviors-q{q}.txt"), aligned_arr)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/compmass/")
  q=1000
  dirname = f"."
  params = np.loadtxt(os.path.join(".", f"behaviors-q{q}.txt"))
  fig, ax = plt.subplots(figsize=(8,6))
  
  align_ind = (params[:,4] == 1).astype("bool")
  antialign_ind =  (params[:,5] == 1).astype("bool")
  circ_ind = np.logical_and(np.logical_not(align_ind), np.logical_not(antialign_ind))
  ax.scatter(params[align_ind, 2], params[align_ind, 3],
             marker="o", c="k", s=120, label=r"$\Delta\varpi\to 0$")
  ax.scatter(
      params[circ_ind, 2], params[circ_ind, 3],
      marker="o",
      s=120,
      facecolors="none",
      edgecolors="k",
      label=r"$\Delta\varpi$-circulating")
  ax.scatter(
      params[antialign_ind, 2], params[antialign_ind, 3],
      marker="o",
      s=120,
      c="r",
      label=r"$\Delta\varpi\to\pi$")
  
  fontsize=32
  ax.set_xscale("log")
  ax.set_yscale("log")
  ax.set_ylabel(r"$e_{2,\rm eq}$",fontsize=fontsize)
  ax.set_xlabel(r"$e_{1,\rm init}$",fontsize=fontsize)
  
  ax.tick_params(axis="both", labelsize=fontsize)
  ax.set_title(f"q={q}",fontsize=fontsize)
  ax.legend(bbox_to_anchor=(1.01, 1.03))
  fig.savefig(os.path.join(dirname, f"align-q{q}.png"), bbox_inches="tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/fd864a3d30156244ac1b92862a8389b89ba9e15e.png]]

*** test particle comparison
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/tp/external-grid-1e-3-long/")
  i = 0
  mup = 1e-3
  T = 2e5
  Tm = -1e6
  tol = 1e-6
  galigns = np.loadtxt("behaviors.txt", skiprows=1, delimiter=",")
  ep = galigns[:, 0]
  eeq = galigns[:, 1]
  aligns = galigns[:, 3]
  mask_circ = aligns > 0
  mask_align = aligns < 1
  
  ep_circ = np.ma.masked_array(ep, mask=mask_circ)
  ep_align = np.ma.masked_array(ep, mask=mask_align)
  
  eeq_circ = np.ma.masked_array(eeq, mask=mask_circ)
  eeq_align = np.ma.masked_array(eeq, mask=mask_align)
  
  fig, ax = plt.subplots(figsize=(8,6))
  ax.scatter(
      ep_circ,
      eeq_circ,
      marker="o",
      s=120,
      facecolors="none",
      edgecolors="k",
      label=r"$\Delta\varpi$-circulating",
  )
  ax.scatter(ep_align, eeq_align, marker="o", c="k", s=120, label=r"$\Delta\varpi\to0$")
  ax.set_xscale("log",)
  ax.set_yscale("log")
  ax.set_xlabel(r"$e_{1,\rm const}$", fontsize=32)
  ax.set_ylabel(r"$e_{2, \rm eq}$", fontsize=32)
  ax.legend(bbox_to_anchor=(1.01, 1.03))
  ax.set_title(r"$q=\infty$", fontsize=32)
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/compmass/")
  fig.savefig(f"align-ER3BP.png", bbox_inches="tight")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/e924cc2be0e86021f326b3a5ee8dc3f4339e6a48.png]]

** driving eccentricities
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/compmass-eq/qles1")
  #################
  # CONFIGURATION #
  #################
  j = 2
  a0 = 1.0
  h = 0.025
  alpha_0 = (j/(j+1))**(2./3.)
  Nqs = 24
  qs = np.zeros(Nqs)
  Nqs3 = int(Nqs/3)
  qs[0:Nqs3] = 10.*np.ones(Nqs3)
  qs[Nqs3:2*Nqs3] = 100.*np.ones(Nqs3)
  qs[2*Nqs3:] = 1000.*np.ones(Nqs3)
  overwrite = False
  T = 5e4
  
  totmass = 1e-3
  
  Tw0 = 1e3
  e1d = 0.1
  e2d = 0.1
  
  ####################
  # THREADING ARRAYS #
  ####################
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  
  
  TM1 = -np.ones(len(QS))*1e6
  TM2 = TM1/10.
  
  #TE1 = np.abs(TM1)*e1disk**2
  #TE2 = np.abs(TM2)*e2d**2
  TE1 = np.ones(Nqs)*Tw0
  TE23 = np.logspace(np.log10(Tw0)-2, np.log10(Tw0)+2, Nqs3)
  TE2 = np.ones(Nqs)
  TE2[0:Nqs3] = TE23
  TE2[Nqs3:2*Nqs3] = TE23
  TE2[2*Nqs3:] = TE23
  
  E1_0 = np.ones(len(QS))*0.001
  E2_0 = np.ones(len(QS))*0.001
  ALPHA2_0 = (3/2.)**(2./3)*(1+e1d**2+e2d**2)*np.ones(len(QS))
  NAMES = np.array([f"q{qit:0.3f}-Te1-{TE1[i]:0.3f}-Te2-{TE2[i]:0.3f}"
                    for i, qit in enumerate(QS)])
  RUN_PARAMS = np.column_stack((QS, MU1, TE1, TE2, TM1, TM2, E1_0, E2_0, ALPHA2_0, NAMES))
  dirname = "/home/jtlaune/Dropbox/multi-planet-architecture/runs/compmass-eq/qles1/varyTe2-e1d0.100-e2d0.010"
  
  aligned_arr = np.zeros((Nqs, 7))
  aligned_arr[:,0] = totmass
  aligned_arr[:,1] = QS
  aligned_arr[:,2] = TE1
  aligned_arr[:,3] = TE2
  aligned_arr[:,4] = e1d
  aligned_arr[:,5] = e2d
  
  for i, filename in enumerate(NAMES):
      data = np.load(os.path.join(dirname, filename+".npz"))
      teval  = data["teval"]
      theta = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]
  
      it = int(len(teval)*0.9)
      align = 1*np.all((np.abs((g1[it:]-g2[it:])%(2*pi) - pi) > 0.5))
      aligned_arr[i,6] = align
  np.savetxt(os.path.join(dirname, "behaviors.txt"), aligned_arr)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  e1d = 0.1
  e2d = 0.01
  dirname = f"./varyTe2-e1d{e1d:0.3f}-e2d{e2d:0.3f}"
  params = np.loadtxt(os.path.join(dirname, "behaviors.txt"))
  fig, ax = plt.subplots(figsize=(4,3))
  
  align_ind = (params[:,6] == 1).astype("bool")
  circ_ind =  (params[:,6] == 0).astype("bool")
  print(align_ind)
  ax.scatter(params[align_ind, 2]/params[align_ind, 3], params[align_ind, 1],
             marker="o", c="k", s=120, label=r"$\varpi$-aligned")
  ax.scatter(
      params[circ_ind, 2]/params[circ_ind, 3], params[circ_ind, 1],
      marker="o",
      s=120,
      facecolors="none",
      edgecolors="k",
      label=r"$\Delta\varpi$-circulating")
  
  ax.set_xscale("log")
  ax.set_yscale("log")
  ax.set_title(r"$e_{1,d}/e_{2,d}$ = " + f"{e1d/e2d}")
  ax.set_ylabel(r"$q = m_1/m2$")
  ax.set_xlabel(r"$T_{e,1,d}/T_{e,2,d}$")
  ax.legend(bbox_to_anchor=(1.01, 1.03))
  fig.savefig(os.path.join(dirname, "align.png"), bbox_inches="tight")
#+END_SRC

#+RESULTS:
: [False False  True  True False False False False  True  True  True  True
:  False False False False  True  True  True  True False False False False]

* Hat theta
** preamble
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import scipy.signal
  import scipy.ndimage
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  from plotting import *
  import importlib
  import os
  j = 2
  plt.rcParams.update({"font.size": 20, "figure.facecolor": "white", "figure.figsize": (10,10)})
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/notes/")
#+END_SRC

#+RESULTS:

** gen behaviortxt
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
  
  #################
  # CONFIGURATION #
  #################
  h = 0.03
  j = 2
  a0 = 0.7
  qRun = 16
  Nqs = 16
  qs = np.ones(Nqs)*2.
  overwrite = True
  totmass = 1.0e-4
  Tw0 = 1000
  TeRatios = sqrt(qs)
  
  ######################
  # Varying parameters #
  ######################
  E1_0 = np.ones(Nqs)*0.001
  E2_0 = np.ones(Nqs)*0.001
  
  e1ds = np.linspace(0,0.3,4)
  e2ds = np.linspace(0,0.3,4)
  
  E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
  E1DS_single = E1DS_single.flatten()
  E2DS_single = E2DS_single.flatten()
  
  E1DS = np.array([])
  E2DS = np.array([])
  for i in range(int(Nqs/qRun)):
      E1DS = np.append(E1DS, E1DS_single)
      E2DS = np.append(E2DS, E2DS_single)
  print(len(E1DS))
  
  G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  
  TE_FUNCS = np.zeros(Nqs)
  TE1 = Tw0/TeRatios
  TE2 = Tw0*TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
  TS = 30.*np.maximum(TE1, TE2)
  #############################################################
  # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
  # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
  #############################################################
  cutoff_frac = 1.0
  CUTOFFS = TS*cutoff_frac
  ALPHA2_0 = (3/2.)**(2./3)*np.ones(Nqs) #*(0.95*(QS>=1) + 1.05*(QS<1))
  NAMES = np.array([f"e1d-{E1DS[i]:0.1f}-e2d-{E2DS[i]:0.1f}"
                    for i, qit in enumerate(QS)])
  
  DIRNAMES = np.array([f"./driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                          in range(Nqs)])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
  aligned_arr = np.zeros((Nqs, 13))
  aligned_arr[:,0] = totmass
  aligned_arr[:,1] = QS
  aligned_arr[:,2] = E1DS
  aligned_arr[:,3] = E2DS
  
  for i, filename in enumerate(NAMES):
      data = np.load(os.path.join(DIRNAMES[i], filename+".npz"))
      teval  = data["teval"]
      theta = data["thetap"]
      a1     = data["a1"]
      a2     = data["a2"]
      e1     = data["e1"]
      e2     = data["e2"]
      g1     = data["g1"]
      g2     = data["g2"]
      L1     = data["L1"]
      L2     = data["L2"]
      x1     = data["x1"]
      y1     = data["y1"]
      x2     = data["x2"]
      y2     = data["y2"]
  
      it = int(len(teval)*0.9)
      #xi_avg = np.average(x1[it:]-x2[it:])
      #yi_avg = np.average(y1[it:]-y2[it:])
      Dpoms = g1[it:]-g2[it:]
      Dpom_avg = np.arctan2(np.sum(np.sin(Dpoms)), np.sum(np.cos(Dpoms)))
      Dpom_std = np.sqrt(np.sum(Dpoms-Dpom_avg)**2)/len(Dpoms)
  
      f1 = A(a1/a2, j)
      f2 = B(a1/a2, j)
      theta1 = theta + g1
      theta2 = theta + g2
      hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                            e1*cos(theta1) + f2/f1*e2*cos(theta2))
      hattheta1s = hattheta1s[it:]
      hattheta1_avg = np.arctan2(np.sum(np.sin(hattheta1s)), np.sum(np.cos(hattheta1s)))
      hattheta1_std = np.sqrt(np.sum(hattheta1s-hattheta1_avg)**2)/len(hattheta1s)
  
      inres = np.all(np.abs(hattheta1s) > 1.)
  
      aligned_arr[i,4] = np.average(e1[it:])
      aligned_arr[i,5] = np.std(e1[it:])
      aligned_arr[i,6] = np.average(e2[it:])
      aligned_arr[i,7] = np.std(e2[it:])
      aligned_arr[i,8] = Dpom_avg
      aligned_arr[i,9] = Dpom_std
      aligned_arr[i,10] = hattheta1_avg
      aligned_arr[i,11] = hattheta1_std
      aligned_arr[i,12] = inres
  np.savetxt(os.path.join(".", f"behaviors-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}.txt"), aligned_arr)
#+END_SRC

#+RESULTS:
: 16
  
** plotting numerical
- why is q=0.5 so different from q=2?
- look at diagonal runs for q=0.5. weird dynamics. maybe pluto-neptune
  pi/2?
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
  h = 0.03
  totmass = 1e-4
  filename = f"behaviors-driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}.txt"
  qRun = 16
  QS_it = [2.0]
  fig, ax = plt.subplots(len(QS_it)*1,2,figsize=(10,5*len(QS_it)))
  if len(QS_it):
      ax =np.array([ax[:]])
  for i, qit in enumerate(QS_it):
      params = np.loadtxt(os.path.join(".", filename))[i*qRun:(i+1)*qRun]
  
      fontsize=24
  
      inres = params[:,12].astype("bool")
      #hattheta1s = params[:,10]
      #hattheta1s_std = params[:,11]
      #inres = np.logical_and(hattheta1s_std < 1.0, np.abs(np.sin(hattheta1s)) < 0.5)
  
      totmass = params[:,0][inres]
      qs = params[:,1][inres]
      e1ds = params[:,2][inres]
      e2ds = params[:,3][inres]
  
      e1s = params[:,4][inres]
      e1s_std = params[:,5][inres]
      e2s = params[:,6][inres]
      e2s_std = params[:,7][inres]
      Dpoms = params[:,8][inres]
      print(Dpoms)
      Dpoms_std = params[:,9][inres]
      hattheta1s = params[:,10][inres]
      hattheta1s_std = params[:,11][inres]
  
      aligned = np.abs(Dpoms) < 1.0
      antialigned = np.logical_not(aligned)
  
      cs = ax[i,0].scatter(e1ds[aligned], e2ds[aligned],  s=75, facecolors='k', edgecolors='k')
      cs = ax[i,0].scatter(e1ds[antialigned], e2ds[antialigned],  s=75, facecolors='none', edgecolors='k')
  
      cs = ax[i,1].errorbar(e1s[aligned], e2s[aligned], xerr=e1s_std[aligned], yerr=e2s_std[aligned], fmt='o', ms=7.5, markerfacecolor='k', markeredgecolor='k', c="k")
      cs = ax[i,1].errorbar(e1s[antialigned], e2s[antialigned], xerr=e1s_std[antialigned], yerr=e2s_std[antialigned], ms=7.5, fmt='o', markerfacecolor='none', markeredgecolor='k',c="k")
      #cb = fig.colorbar(cs, ax=ax[i,1])
  
      #cb.ax.tick_params(labelsize=fontsize)
      #cb.set_label(r"$\hat{R}$", rotation=270, fontsize=fontsize, labelpad=60)
  
      ax[i,0].set_xlabel(r"$e_{1,d}$",fontsize=fontsize)
      ax[i,0].set_ylabel(r"$e_{2,d}$",fontsize=fontsize)
  
      ax[i,1].set_xlabel(r"numerical $e_{1}$",fontsize=fontsize)
      ax[i,1].set_ylabel(r"numerical $e_{2}$",fontsize=fontsize)
  
      xlin = np.linspace(0,0.5,100)
      ax[i,1].plot(xlin, qit*xlin, "k--", label=r"$y=qx$")
      ax[i,1].plot(xlin, xlin, "r--", label=r"$y=x$")
      ax[i,1].set_xlim(0.,0.4)
      ax[i,1].set_ylim(0.,0.4)
      fig.subplots_adjust(wspace=0.4)
      #ax[i,1].set_xlim(0,0.6)
      #ax[i,1].set_ylim(0,0.3)
  ax[0,1].text(0.05,0.35,r"$y=2x$")
  ax[0,1].text(0.25,0.35,r"$y=x$",c="r")
  
  os.chdir("/home/jtlaune/multi-planet-architecture/docs/apsidal-alignment/")
  fig.savefig(os.path.join(".",
              "Rhat-grid.png"),
              bbox_inches="tight")
#+END_SRC

#+RESULTS:
:RESULTS:
: [-3.12127726  0.10886437  0.23641767  0.28378325  2.99980532  0.02076678
:   0.22173402 -1.49893254 -3.08953736  2.38227561 -0.02686384 -1.53963981
:  -2.51670634  2.91886473]
[[file:./.ob-jupyter/cdf13a49df97589380782412dcf986012262893a.png]]
:END:

** plotting analytic 
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  alpha_0 = (j/(j+1))**(2./3.)
  f1 = -A(alpha_0, j)
  f2 = -B(alpha_0, j)
  
  alpha = np.arctan2(-f1, f2)
  
  def hattheta1(e1, e2, theta1, theta2):
      return(np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2)))
  def hattheta2(e1, e2, theta1, theta2):
      return(np.arctan2(e2*sin(theta2) + f1/f2*e1*sin(theta1),
                        e2*cos(theta2) + f1/f2*e1*cos(theta1)))
  
  Necc = 100
  Ntheta = 100
  
  eccs = np.linspace(0, 0.1, Necc) 
  e1s, e2s = np.meshgrid(eccs, eccs)
  
  import scipy.stats as stats
  
  lower, upper = 0., 2*pi
  mu, sigma = pi, 1.
  theta1_dist = stats.truncnorm((lower - mu) / sigma, (upper - mu) / sigma, loc=mu, scale=sigma)
  lower, upper = -pi, pi
  mu, sigma = 0., 1.
  theta2_dist = stats.truncnorm((lower - mu) / sigma, (upper - mu) / sigma, loc=mu, scale=sigma)
  
  theta1 = theta1_dist.rvs(Ntheta)
  theta2 = theta2_dist.rvs(Ntheta)
  
  avg_hatRs = np.zeros(len(e1s.flatten()))
  Phip1s = np.zeros(len(e1s.flatten()))
  Phip2s = np.zeros(len(e2s.flatten()))
  
  q = 1
  mutot = 1e-4
  mu2 = mutot/(1+q)
  mu1 = q*mu2
  
  for i in range(len(e1s.flatten())):
      e1 = e1s.flatten()[i]
      e2 = e2s.flatten()[i]
  
      hattheta1_grid = hattheta1(e1, e2, theta1, theta2)
      W2_grid = -e1*cos(theta1)*sin(alpha) + e2*cos(theta2)*cos(alpha)
      Rhat_grid = 0.125*(f2*W2_grid/cos(alpha)/cos(hattheta1_grid)/mutot**(1./3))**2
      avg_hatRs[i] = np.average(Rhat_grid) 
      Phip1s[i] = 0.5*(3.75*(j+1)/mu1)**(2./3)*e1**2
      Phip2s[i] = 0.5*(3.75*(j+1)/mu2)**(2./3)*e2**2
  
  avg_hatRs_grid = avg_hatRs.reshape((Necc, Necc))
  Phip1s_grid = Phip1s.reshape((Necc, Necc))
  Phip2s_grid = Phip2s.reshape((Necc, Necc))
  
#+END_SRC
  
** phase space splitting (?)
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  # thank you https://numbersmithy.com/how-to-label-the-contour-lines-at-the-edge-of-a-matplotlib-plot/
  def labelAtEdge(levels, cs, ax, e1d, side='both', pad=0.005, **kwargs):
     '''Label contour lines at the edge of plot
  
     Args:
         levels (1d array): contour levels.
         cs (QuadContourSet obj): the return value of contour() function.
         ax (Axes obj): matplotlib axis.
         fmt (str): formating string to format the label texts. E.g. '%.2f' for
             floating point values with 2 demical places.
     Keyword Args:
         side (str): on which side of the plot intersections of contour lines
             and plot boundary are checked. Could be: 'left', 'right', 'top',
             'bottom' or 'all'. E.g. 'left' means only intersections of contour
             lines and left plot boundary will be labeled. 'all' means all 4
             edges.
         pad (float): padding to add between plot edge and label text.
         ,**kwargs: additional keyword arguments to control texts. E.g. fontsize,
             color.
     '''
  
     from matplotlib.transforms import Bbox
     collections = cs.collections
     xlim = ax.get_xlim()
     ylim = ax.get_ylim()
     bbox = Bbox.from_bounds(xlim[0], ylim[0], xlim[1]-xlim[0], ylim[1]-ylim[0])
  
     eps = 1e-5  # error for checking boundary intersection
  
     # -----------Loop through contour levels-----------
     for ii, lii in enumerate(levels):
  
         cii = collections[ii]  # contours for level lii
         pathsii = cii.get_paths()  # the Paths for these contours
         if len(pathsii) == 0:
             continue
  
         for pjj in pathsii:
  
             # check first whether the contour intersects the axis boundary
             if not pjj.intersects_bbox(bbox, False):  # False significant here
                 pass
  
             xjj = pjj.vertices[:, 0]
             yjj = pjj.vertices[:, 1]
  
             # intersection with the left edge
             if side in ['left', 'all']:
                 inter_idx = np.where(abs(xjj-xlim[0]) <= eps)[0]
                 for kk in inter_idx:
                     inter_x = xjj[kk]
                     inter_y = yjj[kk]
  
                     ax.text(inter_x-pad, inter_y, e1d,
                             ha='right',
                             va='center',
                             ,**kwargs)
  
             # intersection with the right edge
             if side in ['right', 'all']:
                 inter_idx = np.where(abs(xjj-xlim[1]) <= eps)[0]
                 for kk in inter_idx:
                     inter_x = xjj[kk]
                     inter_y = yjj[kk]
  
                     ax.text(inter_x+pad, inter_y, e1d,
                             ha='left',
                             va='center',
                             ,**kwargs)
  
             # intersection with the bottom edge
             if side in ['bottom', 'all']:
                 inter_idx = np.where(abs(yjj-ylim[0]) <= eps)[0]
                 for kk in inter_idx:
                     inter_x = xjj[kk]
                     inter_y = yjj[kk]
  
                     ax.text(inter_x-pad, inter_y, e1d,
                             ha='center',
                             va='top',
                             ,**kwargs)
  
             # intersection with the top edge
             if side in ['top', 'all']:
                 inter_idx = np.where(abs(yjj-ylim[-1]) <= eps)[0]
                 for kk in inter_idx:
                     inter_x = xjj[kk]
                     inter_y = yjj[kk]
  
                     ax.text(inter_x+pad, inter_y, e1d,
                             ha='center',
                             va='bottom',
                             ,**kwargs)
  
     return 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  q = np.logspace(-1,1,1000)
  h = np.linspace(0.01, 0.1,1000)
  Q, H = np.meshgrid(q,h)
  fig, ax = plt.subplots(figsize=(6,6))
  e1ds = [0.05, 0.1, 0.15, 0.2, 0.25, 0.3]
  Delta = 0.1
  for i,e1d in enumerate(e1ds):
      hcond = np.abs(np.abs(e1d-H*sqrt(Q))-H) < Delta
      cs1 = ax.contour(Q, H, hcond, levels=0., inline=True)
      labelAtEdge(cs1.levels, cs1, ax, f"{e1d:0.2f}", side='right', pad=0.2)
  ax.set_ylabel("h")
  ax.set_xlabel("q")
  ax.scatter(2, 0.03,s=10)
#+END_SRC

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_23770/1765676941.py:9: UserWarning: No contour levels were found within the data range.
:   cs1 = ax.contour(Q, H, hcond, levels=0., inline=True)
: /tmp/ipykernel_23770/1765676941.py:9: UserWarning: The following kwargs were not used by contour: 'inline'
:   cs1 = ax.contour(Q, H, hcond, levels=0., inline=True)
: <matplotlib.collections.PathCollection at 0x7f0e3b27ddf0>
#+attr_org: :width 452
[[file:./.ob-jupyter/65e20ac5c850ebc064282b011bc5ddaba7ee798b.png]]
:END:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def plotanal(plot_iter, cut_iter=[0,-1]):
      os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
      #################
      # CONFIGURATION #
      #################
      h = 0.03
      j = 2
      a0 = 0.7
      qRun = 16
      Nqs = 16
      qs = np.ones(Nqs)*2.
      overwrite = True
      totmass = 1.0e-4
      Tw0 = 1000
      TeRatios = sqrt(qs)
  
      ######################
      # Varying parameters #
      ######################
      E1_0 = np.ones(Nqs)*0.001
      E2_0 = np.ones(Nqs)*0.001
  
      e1ds = np.linspace(0,0.3,4)
      e2ds = np.linspace(0,0.3,4)
  
      E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
      E1DS_single = E1DS_single.flatten()
      E2DS_single = E2DS_single.flatten()
  
      E1DS = np.array([])
      E2DS = np.array([])
      for i in range(int(Nqs/qRun)):
          E1DS = np.append(E1DS, E1DS_single)
          E2DS = np.append(E2DS, E2DS_single)
      print(len(E1DS))
  
      G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
      G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = qs
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
  
      TE_FUNCS = np.zeros(Nqs)
      TE1 = Tw0/TeRatios
      TE2 = Tw0*TeRatios
      #TM1 = np.infty*np.ones(Nqs)
      TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TS = 30.*np.maximum(TE1, TE2)
      #############################################################
      # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
      # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
      #############################################################
      cutoff_frac = 1.0
      CUTOFFS = TS*cutoff_frac
      ALPHA2_0 = (3/2.)**(2./3)*np.ones(Nqs) #*(0.95*(QS>=1) + 1.05*(QS<1))
      NAMES = np.array([f"e1d-{E1DS[i]:0.1f}-e2d-{E2DS[i]:0.1f}"
                        for i, qit in enumerate(QS)])
  
      DIRNAMES = np.array([f"./driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                              in range(Nqs)])
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
      fname = os.path.join(DIRNAMES[plot_iter], NAMES[plot_iter]+".npz")
      print(fname)
      data = np.load(fname)
      teval  = data["teval"][cut_iter[0]:cut_iter[-1]]
      theta = data["thetap"][cut_iter[0]:cut_iter[-1]]
      a1     = data["a1"][cut_iter[0]:cut_iter[-1]]
      a2     = data["a2"][cut_iter[0]:cut_iter[-1]]
      e1     = data["e1"][cut_iter[0]:cut_iter[-1]]
      e2     = data["e2"][cut_iter[0]:cut_iter[-1]]
      g1     = data["g1"][cut_iter[0]:cut_iter[-1]]
      g2     = data["g2"][cut_iter[0]:cut_iter[-1]]
      L1     = data["L1"][cut_iter[0]:cut_iter[-1]]
      L2     = data["L2"][cut_iter[0]:cut_iter[-1]]
      x1     = data["x1"][cut_iter[0]:cut_iter[-1]]
      y1     = data["y1"][cut_iter[0]:cut_iter[-1]]
      x2     = data["x2"][cut_iter[0]:cut_iter[-1]]
      y2     = data["y2"][cut_iter[0]:cut_iter[-1]]
  
      #xi_avg = np.average(x1[it:]-x2[it:])
      #yi_avg = np.average(y1[it:]-y2[it:])
      Dpoms = g1-g2
      Dpom_avg = np.arctan2(np.sum(np.sin(Dpoms)), np.sum(np.cos(Dpoms)))
      Dpom_std = np.sqrt(np.sum(Dpoms-Dpom_avg)**2)/len(Dpoms)
  
      f1 = A(a1/a2, j)
      f2 = B(a1/a2, j)
      theta1 = (theta + g1) % (2*np.pi)
      theta2 = (theta + g2) % (2*np.pi)
      hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                            e1*cos(theta1) + f2/f1*e2*cos(theta2))
      hattheta1s = hattheta1s
      hattheta1_avg = np.arctan2(np.sum(np.sin(hattheta1s)), np.sum(np.cos(hattheta1s)))
      hattheta1_std = np.sqrt(np.sum(hattheta1s-hattheta1_avg)**2)/len(hattheta1s)
  
      Rhat = np.abs(f1*e1**2+f2*e2**2+f1*f2*e1*e2*cos(Dpoms))
      ehat = np.sqrt(Rhat)
      fig, ax = plt.subplots(3) 
      ax[0].scatter(teval, e1, s=0.5, label="e1")
      ax[0].scatter(teval, e2, s=0.5, label="e2")
      ax[0].scatter(teval, ehat, s=0.5, label="Rhat")
      ax[0].legend()
      ax[1].scatter(teval, Dpoms*180/pi, s=0.5, alpha=0.2)
      ax[2].scatter(teval, theta1*180/pi, s=0.5, alpha=0.2)
      ax[2].scatter(teval, theta2*180/pi, s=0.5, alpha=0.2)
      ax[2].scatter(teval, hattheta1s*180/pi, s=0.5, alpha=0.2)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  leng = 300000
  plotanal(0,cut_iter=[int(0.8*leng),int(0.81*leng)])
#+END_SRC

#+RESULTS:
:RESULTS:
: 16
: ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.0.npz
[[file:./.ob-jupyter/bbdf11228552005a7343f1f2354a6ccdab9c8417.png]]
:END:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  leng = 300000
  plotanal(1,cut_iter=[int(0.8*leng),int(0.81*leng)])
#+END_SRC

#+RESULTS:
:RESULTS:
: 16
: ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.1-e2d-0.0.npz
[[file:./.ob-jupyter/40b90a5d1fa732da1b335565592ddd8b785e08ed.png]]
:END:

** e vectors
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def plotorbit(plot_iter, cuts, fig, ax):
      os.chdir("/home/jtlaune/multi-planet-architecture/runs/Rhat-grid/")
      #################
      # CONFIGURATION #
      #################
      h = 0.03
      j = 2
      a0 = 0.7
      qRun = 16
      Nqs = 16
      qs = np.ones(Nqs)*2.
      overwrite = True
      totmass = 1.0e-4
      Tw0 = 1000
      TeRatios = sqrt(qs)
  
      ######################
      # Varying parameters #
      ######################
      E1_0 = np.ones(Nqs)*0.001
      E2_0 = np.ones(Nqs)*0.001
  
      e1ds = np.linspace(0,0.3,4)
      e2ds = np.linspace(0,0.3,4)
  
      E1DS_single, E2DS_single = np.meshgrid(e1ds, e2ds)
      E1DS_single = E1DS_single.flatten()
      E2DS_single = E2DS_single.flatten()
  
      E1DS = np.array([])
      E2DS = np.array([])
      for i in range(int(Nqs/qRun)):
          E1DS = np.append(E1DS, E1DS_single)
          E2DS = np.append(E2DS, E2DS_single)
      print(len(E1DS))
  
      G1_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
      G2_0 = np.array([np.random.uniform(0, 2*np.pi) for i in range(Nqs)])
  
      ####################
      # THREADING ARRAYS #
      ####################
      HS = np.ones(Nqs)*h
      JS = np.ones(Nqs)*j
      A0S = np.ones(Nqs)*a0
      QS = qs
      MU2 = totmass/(1+QS)
      MU1 = totmass - MU2
  
      TE_FUNCS = np.zeros(Nqs)
      TE1 = Tw0/TeRatios
      TE2 = Tw0*TeRatios
      #TM1 = np.infty*np.ones(Nqs)
      TM1 = TE1/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TM2 = TE2/3.46/HS**2*(-1*(qs<1) + 1*(qs>=1))
      TS = 30.*np.maximum(TE1, TE2)
      #############################################################
      # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
      # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
      #############################################################
      cutoff_frac = 1.0
      CUTOFFS = TS*cutoff_frac
      ALPHA2_0 = (3/2.)**(2./3)*np.ones(Nqs) #*(0.95*(QS>=1) + 1.05*(QS<1))
      NAMES = np.array([f"e1d-{E1DS[i]:0.1f}-e2d-{E2DS[i]:0.1f}"
                        for i, qit in enumerate(QS)])
  
      DIRNAMES = np.array([f"./driveTe-h-{h:0.2f}-mutot-{totmass:0.1e}-Tw0-{Tw0}-q{QS[i]:0.1f}" for i
                              in range(Nqs)])
      DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
      fname = os.path.join(DIRNAMES[plot_iter], NAMES[plot_iter]+".npz")
      print(fname)
      data = np.load(fname)
      teval  = data["teval"]
      print(teval[cuts[0]], teval[cuts[-1]])
      for cut_iter in cuts:
          data = np.load(fname)
          teval  = data["teval"][cut_iter]
          theta = data["thetap"][cut_iter]
          a1     = data["a1"][cut_iter]
          a2     = data["a2"][cut_iter]
          e1     = data["e1"][cut_iter]
          e2     = data["e2"][cut_iter]
          g1     = data["g1"][cut_iter]
          g2     = data["g2"][cut_iter]
          L1     = data["L1"][cut_iter]
          L2     = data["L2"][cut_iter]
          x1     = data["x1"][cut_iter]
          y1     = data["y1"][cut_iter]
          x2     = data["x2"][cut_iter]
          y2     = data["y2"][cut_iter]
  
          #xi_avg = np.average(x1[it:]-x2[it:])
          #yi_avg = np.average(y1[it:]-y2[it:])
          Dpoms = g1-g2
  
          f1 = A(a1/a2, j)
          f2 = B(a1/a2, j)
          theta1 = (theta + g1) % (2*np.pi)
          theta2 = (theta + g2) % (2*np.pi)
          hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                                e1*cos(theta1) + f2/f1*e2*cos(theta2))
  
          hatgamma1 = hattheta1s-theta
          Rhat = np.abs(f1*e1**2+f2*e2**2+f1*f2*e1*e2*cos(Dpoms))
          ehat = np.sqrt(Rhat)
  
          if cut_iter == cuts[0]:
              ax.scatter(e1*sqrt(2)*cos(pi),e1*sqrt(2)*sin(pi), c="k",label=r"$\mathbf{e_1}$",zorder=2)
              ax.scatter(e2/sqrt(2)*cos(pi+Dpoms),e2/sqrt(2)*sin(pi+Dpoms), c="r",label=r"$\mathbf{e_2}$",zorder=1)
              ax.scatter(ehat*cos(pi+hatgamma1),ehat*sin(pi+hatgamma1), c="g",label=r"$\mathbf{\hat\theta}$",zorder=0)
          else:
              ax.scatter(e1*sqrt(2)*cos(pi),e1*sqrt(2)*sin(pi), c="k",zorder=2)
              ax.scatter(e2/sqrt(2)*cos(pi+Dpoms),e2/sqrt(2)*sin(pi+Dpoms), c="r",zorder=1)
              ax.scatter(ehat*cos(pi+hatgamma1-g1),ehat*sin(pi+hatgamma1-g1), c="g",zorder=0)
  
          #lambdas = np.linspace(0,2*np.pi,1000)
          #radii1 = a1*(1-e1**2)/(1-e1*cos(lambdas))
          #print(e1,e2)
          #radii2 = a2*(1-e2**2)/(1-e2*cos(lambdas-Dpoms))
          #ax.scatter(radii1*cos(lambdas), radii1*sin(lambdas), s=0.01, c="r")
          #ax.scatter(radii2*cos(lambdas), radii2*sin(lambdas), s=0.01, c="k")
      #ax.set_xlim(-1.5,1.5)
      #ax.set_ylim(-1.5,1.5)
      ax.axhline(y=0,ls="--",c="k")
      ax.axvline(x=0,ls="--",c="k")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fig, ax = plt.subplots(3,2,figsize=(10,15))
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(0,lengs, fig, ax[0,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(1,lengs, fig, ax[1,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(1,lengs, fig, ax[1,1])
  
  snaps = np.linspace(0.0,0.003,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(3,lengs, fig, ax[2,0])
  snaps = np.linspace(0.8,0.9,100)
  lengs = (snaps*300000).astype(int)
  plotorbit(3,lengs, fig, ax[2,1])
  
  
  for axi in ax.flatten():
      axi.set_xlim(-0.2,0.2)
      axi.set_ylim(-0.2,0.2)
      axi.set_ylabel(r"$e\sin\gamma$")
      axi.set_xlabel(r"$e\cos\gamma$")
  fig.subplots_adjust(wspace=0.3,hspace=0.4)
  ax[0,0].text(0.01,0.15,r"$e_{1d}=e_{2d}=0$")
  ax[1,0].text(0.01,0.1,r"$e_{1d}=0.1$"+"\n"+ r"$e_{2d}=0$")
  ax[2,0].text(0.01,0.1,r"$e_{1d}=0$"+"\n"+ r"$e_{2d}=0.1$")
  
  ax[0,0].text(-0.17,-.17,r"$t=0-127$ orbits",c="r")
  ax[0,1].text(-0.17,-.17,r"$t=34-38,000$ orbits",c="r")
  
  ax[0,0].legend(loc="upper left")
  fig.suptitle(r"$\mathbf{e}$ vectors in $\mathbf{e_1}$ rest frame")
  
  ax[1,0].arrow(0,0,-0.1,0,width=0.005,color="k",ls="--")
  ax[1,1].arrow(0,0,-0.1,0,width=0.005,color="k",ls="--")
  ax[2,0].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
  ax[2,1].arrow(0,0,0.1,0, width=0.005,color="r",ls="--")
#+END_SRC

#+RESULTS:
:RESULTS:
#+begin_example
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.0.npz
  0.0 127.2796448790615
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.0-e2d-0.0.npz
  33941.2386344164 38183.89346371845
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.1-e2d-0.0.npz
  0.0 127.2796448790615
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.1-e2d-0.0.npz
  33941.2386344164 38183.89346371845
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.3-e2d-0.0.npz
  0.0 127.2796448790615
  16
  ./driveTe-h-0.03-mutot-1.0e-04-Tw0-1000-q2.0/e1d-0.3-e2d-0.0.npz
  33941.2386344164 38183.89346371845
#+end_example
: <matplotlib.patches.FancyArrow at 0x7f331dc3d0d0>
[[file:./.ob-jupyter/161cc2adedcce3182cfaaca8b0ba0ab1d91d4c9d.png]]
:END:


** extras
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  #######################
  # Analytical Contours #
  #######################
  #cs = ax.pcolormesh(e1s, e2s, avg_hatRs_grid)
  #ax.contour(e1s, e2s, Phip1s_grid, colors=["red"], linestyles="dashed", levels=[2.])
  #ax.contour(e1s, e2s, Phip2s_grid, colors=["red"], linestyles="dashed", levels=[2.])
  #ax.contour(e1s, e2s, avg_hatRs_grid, colors=["black"], linestyles="dashed", levels=[2.])
  
  #ax.scatter(
  #    params[antialign_ind, 2], params[antialign_ind, 3],
  #    marker="o",
  #    s=120,
  #    c="r",
  #    label=r"$\Delta\varpi\to\pi$")
  
  #ax.tick_params(axis="both", labelsize=fontsize)
  #ax.set_title(f"q={q} Te1={TE1[0]} Te2={TE2[0]}",fontsize=fontsize)
  
  #handles, labels = ax.get_legend_handles_labels()
  #line1 = mpl.lines.Line2D([0], [0], label=r'$\hat{R}\sim 2$', color='k', linestyle="dashed")
  #line2 = mpl.lines.Line2D([0], [0], label=r'CR3BP: $R\sim 2$', color='r', linestyle="dashed")
  #handles.extend([line1, line2])
  #
  #ax.legend(bbox_to_anchor=(1.2, 1.03), fontsize=fontsize, handles=handles)
#+END_SRC

#+RESULTS:

* stability tests
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  from plotting import *
  import importlib
  import os
  plt.rcParams.update({"font.size": 20, "figure.facecolor": "white", "figure.figsize": (10,10)})
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/notes/")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/compmass-onlyDrag/")
  filename = "driveTe-h-0.10-Tw0-1000-mutot-1.0e-04/e1d-0.250-e2d-0.000.npz"
  filename = "driveTe-h-0.10-Tw0-1000/e1d-0.300-e2d-0.000.npz"
  #filename = "e0large-h-0.10-Tw0-10000-cut-0.30/e10-0.300-e20-0.300.npz"
  data = np.load(filename)
  teval  = data["teval"]
  theta = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  j = 2
  theta = (theta) % (2 * np.pi)
  theta1 = (theta + g1) % (2 * np.pi)
  theta2 = (theta + g2) % (2 * np.pi)
  alpha = a1 / a2
  period_ratio = (alpha) ** (1.5)
  pnom = j / (j + 1)
  pdiff = period_ratio - pnom
  
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  
  bartheta1 = (theta + barg1) % (2*np.pi)
  bartheta2 = (theta + barg2) % (2*np.pi)
  # from the reducing rotation (Henrard et al 1986)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta2 = np.arctan2(e2*sin(theta2) + f1/f2*e1*sin(theta1),
                         e2*cos(theta2) + f1/f2*e1*cos(theta1))
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/notes/")
#+END_SRC

#+RESULTS:
  
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fig, ax = plt.subplots(1,4,figsize=(20,5))
  ax[0].plot(teval, a2*(1-e2))
  ax[0].plot(teval, a1*(1-e1))
  ax[1].plot(teval, a2)
  ax[1].plot(teval, a1)
  ax[2].plot(teval, e2)
  ax[2].plot(teval, e1)
  ax[3].plot(teval, theta)
#+END_SRC

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7ff0f2084a60> |
[[file:./.ob-jupyter/7e8834c69dae5050d57ac9b3e6a57d2ea115de16.png]]
:END:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fig, ax = plt.subplots()
  alpha = np.linspace(0.5,1,1000)
  q = np.logspace(-1,1,1000)
  AA, QQ = np.meshgrid(alpha, q)
  MUcrit = (1+QQ)*((1-AA)/(AA+QQ**(1./3)))**3.
  levels = np.array([1e-5, 1e-4, 1e-3, 1e-2, 1e-1])
  cs = ax.contourf(AA,QQ,MUcrit,levels=levels,norm=mpl.colors.LogNorm())
  ax.set_yscale("log")
  plt.colorbar(cs)
  js = np.arange(1,6)
  a0s = (js/(js+1))**(2./3)
  for a0 in a0s:
      ax.axvline(x=a0, ls="--", c="k")
  ax.set_xlabel(r"$\alpha$")
  ax.set_ylabel(r"$q$")
#+END_SRC

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_7710/1432895569.py:7: UserWarning: Log scale: values of z <= 0 have been masked
:   cs = ax.contourf(AA,QQ,MUcrit,levels=levels,norm=mpl.colors.LogNorm())
: Text(0, 0.5, '$q$')
[[file:./.ob-jupyter/ac0c32aeaea5ebfef2648a2a0fd0761b95acd4d3.png]]
:END:

* weak Te
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  from plotting import *
  import importlib
  import os
  plt.rcParams.update({"font.size": 20, "figure.facecolor": "white", "figure.figsize": (10,10)})
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/notes/")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/")
  #filename = "compmass-Rhat/driveTe-h-0.10-Tw0-1000-mutot-1.0e-04/e1d-0.250-e2d-0.000.npz"
  #filename = "compmass-Rhat/e0large-h-0.10-Tw0-10000-cut-0.30/e10-0.300-e20-0.300.npz"
  
  #filename = "testing-weakTe/weakTe-Te-1.00e+05-mutot-1.0e-04/e10-0.001-e20-0.001.npz"
  
  q = 2.
  j = 2.
  alpha_0 = (j/(j+1))**(2./3)
  
  data = np.load(filename)
  teval  = data["teval"]
  theta = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  j = 2
  theta = (theta) % (2 * np.pi)
  theta1 = (theta + g1) % (2 * np.pi)
  theta2 = (theta + g2) % (2 * np.pi)
  alpha = a1 / a2
  period_ratio = (alpha) ** (1.5)
  pnom = j / (j + 1)
  pdiff = period_ratio - pnom
  
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  
  bartheta1 = (theta + barg1) % (2*np.pi)
  bartheta2 = (theta + barg2) % (2*np.pi)
  # from the reducing rotation (Henrard et al 1986)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta2 = np.arctan2(e2*sin(theta2) + f1/f2*e1*sin(theta1),
                         e2*cos(theta2) + f1/f2*e1*cos(theta1))
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/notes/")
#+END_SRC
  
** adiabatic invariants
*** kick gammas
- try kicking gamma just like kicking e
  - is resonance more sensitive to R or theta ?
- look up results of scattering
- look up chaos in goldstein to analytically assess the situation
- scattering
  - look at goldstein ch 3.10
- runge lenz vector dynamics for intuitive understanding
  - look at goldstein ch 3.9
*** kick eccentricities
- take a look at the evolution of eta for the weakTe case & the
  driveTe case
  - for weakTe, the eta1 & eta2 quantities are smoothly varying
  - for driveTe, the eta1 & eta2 are broken
  - could be an adiabatic variance thing?
 
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/")
  filename = "compmass-Rhat/driveTe-h-0.10-Tw0-1000-mutot-1.0e-04/e1d-0.250-e2d-0.000.npz"
  #filename = "compmass-Rhat/e0large-h-0.10-Tw0-10000-cut-0.30/e10-0.300-e20-0.300.npz"
  
  #figname = "weak-Te.png"
  #filename = "testing-weakTe/weakTe-Te-1.00e+05-mutot-1.0e-04/e10-0.001-e20-0.001.npz"
  
  #figname = "kick-e.png"
  #filename = "/home/jtlaune/Dropbox/multi-planet-architecture/runs/testing-weakTe/edepTe-h-1.00e-01-mutot-1.0e-04/e10-0.001-e20-0.001.npz"
  
  q = 2.
  j = 2.
  alpha_0 = (j/(j+1))**(2./3)
  
  data = np.load(filename)
  teval  = data["teval"]
  theta = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
  
  j = 2
  theta = (theta) % (2 * np.pi)
  theta1 = (theta + g1) % (2 * np.pi)
  theta2 = (theta + g2) % (2 * np.pi)
  alpha = a1 / a2
  period_ratio = (alpha) ** (1.5)
  pnom = j / (j + 1)
  pdiff = period_ratio - pnom
  
  f1 = A(alpha, j)
  f2 = B(alpha, j)
  barg1 = np.arctan2(e2*np.sin(g2), e2*np.cos(g2) + f2*e1/f1)
  barg2 = np.arctan2(e1*np.sin(g1), e1*np.cos(g1) + f1*e2/f2)
  
  bartheta1 = (theta + barg1) % (2*np.pi)
  bartheta2 = (theta + barg2) % (2*np.pi)
  # from the reducing rotation (Henrard et al 1986)
  hattheta1 = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hattheta2 = np.arctan2(e2*sin(theta2) + f1/f2*e1*sin(theta1),
                         e2*cos(theta2) + f1/f2*e1*cos(theta1))
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/notes/")
  
  fig, ax = plt.subplots(2,figsize=(8,8))
  etahat = -q*(alpha-alpha_0)/(j*sqrt(alpha_0)*(q/alpha_0+1)) + q*sqrt(alpha_0)*e1**2 + e2**2
  eta1 = alpha**1.5*(1+j*e1**2)**1.5
  eta2 = alpha**1.5*(1+(j+1)*e2**2)**1.5
  ax[0].scatter(teval, etahat, s=2, label=r"$\hat\eta$")
  ax[1].scatter(teval, eta1, zorder=1, s=2, label=r"$\eta_1$")
  ax[1].scatter(teval, eta2, zorder=0, s=2, label=r"$\eta_2$")
  ax[0].legend()
  ax[1].legend()
  ax[1].set_xlabel("t [yrs]")
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/testing-weakTe/")
  #fig.savefig(figname, bbox_inches="tight")
  
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/240f99d2dd4cda5b7330ff1a342d2e916acfab70.png]]


#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  class Te_kick:
      def __init__(self, Twave, Tkick, a, w):
          self.Twave = Twave
          self.Tkick = Tkick
          self.a = a
          self.w = w
      def __call__(self, e, t):
          if np.abs(t-self.Tkick) < 0.5*self.w:
              return(self.a)
          else:
              return(self.Twave)
  
  Te1 = Te_kick(5e4, 7e4, 10, 1000)
  teval = np.linspace(0,1.5e5, int(1e4))
  Te1_eval = np.zeros(len(teval))
  for i, ti in enumerate(teval):
      Te1_eval[i] = Te1(0, ti)
  plt.plot(teval, Te1_eval)
#+END_SRC

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7f19441d0070> |
[[file:./.ob-jupyter/0c81e85ac8153fe4c0a762b24a917c265f55ecb2.png]]
:END:

** nonlinear Te from Cresswell & Nelson 08
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  class Te_edep:
      def __init__(self, H_r, twave):
          self.H_r = H_r
          self.twave = twave
      def __call__(self, e):
          return(self.twave/0.78*(1-0.14*(e/self.H_r)**2 + 0.06*(e/self.H_r)**3))
  
  twave = 1000
  H_r = 0.03
  
  Te_func = Te_edep(H_r, twave)
  eccs = np.linspace(0,1.,1000)
  plt.plot(eccs, Te_func(eccs))
  plt.yscale("log")
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/3e783b162beab8914832fffda009f6904d918349.png]]

* why e_i -> 0 at Te ratio = 1
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  from plotting import *
  import importlib
  import os
  plt.rcParams.update({"font.size": 20, "figure.facecolor": "white", "figure.figsize": (10,10)})
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/notes/")
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  # one of the signs has to be different for Q1 & Q2, see if you can
  # find the -1 sign error in your arithmetic
  def Q1(j, q):
      alpha0 = (j/(j+1))**(2./3)
      f1 = -A(alpha0, j)
      f2 = -B(alpha0, j)
      return(-(j*(q/alpha0+1)-1))
  
  def Q2(j, q):
      alpha0 = (j/(j+1))**(2./3)
      f1 = -A(alpha0, j)
      f2 = -B(alpha0, j)
      prefac = q*sqrt(alpha0)*f2**2/f1**2
      return(prefac*(q*sqrt(alpha0)+j*(q/alpha0+1)))
  
  j = 2
  alpha0 = (j/(j+1))**(2./3)
  qs = np.logspace(np.log(0.5),np.log(2),1000)
  tau = np.logspace(-1,1,1000)
  TAUS, QS = np.meshgrid(tau, qs)
  Te1 = 1000
  Tm = 1e5
  
  f1 = -A(alpha0, j)
  f2 = -B(alpha0, j)
  
  E1S_SQ_branch1 = Te1/2/Q1(j, QS)/Tm/(1+TAUS*Q2(j,QS)/Q1(j,QS))
  E1S_SQ_branch2 = -Te1/2/Q1(j, QS)/Tm/(1+TAUS*Q2(j,QS)/Q1(j,QS))
  
  
  E2S_SQ_branch1 = alpha0*QS**2*np.abs(f2/f1)**2*E1S_SQ_branch1
  E2S_SQ_branch2 = alpha0*QS**2*np.abs(f2/f1)**2*E1S_SQ_branch2
  
  
  fig, ax = plt.subplots(2,2,figsize=(10,10))
  
  cs1 = ax[0,0].pcolormesh(TAUS,QS,1*(E1S_SQ_branch1>0))
  cs2 = ax[0,1].pcolormesh(TAUS,QS,1*(E1S_SQ_branch2>0))
  cs1 = ax[1,0].pcolormesh(TAUS,QS,1*(E2S_SQ_branch1>0))
  cs2 = ax[1,1].pcolormesh(TAUS,QS,1*(E2S_SQ_branch2>0))
  
  ax[0].set_xlim((0.5,2))
  ax[0].set_ylim((0.5,2))
#+END_SRC

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_2155/1347791429.py:35: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.
:   cs1 = ax[0,0].pcolormesh(TAUS,QS,1*(E1S_SQ_branch1>0))
: /tmp/ipykernel_2155/1347791429.py:36: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.
:   cs2 = ax[0,1].pcolormesh(TAUS,QS,1*(E1S_SQ_branch2>0))
: /tmp/ipykernel_2155/1347791429.py:37: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.
:   cs1 = ax[1,0].pcolormesh(TAUS,QS,1*(E2S_SQ_branch1>0))
: /tmp/ipykernel_2155/1347791429.py:38: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.
:   cs2 = ax[1,1].pcolormesh(TAUS,QS,1*(E2S_SQ_branch2>0))
# [goto error]
: ---------------------------------------------------------------------------
: AttributeError                            Traceback (most recent call last)
: /tmp/ipykernel_2155/1347791429.py in <module>
:      38 cs2 = ax[1,1].pcolormesh(TAUS,QS,1*(E2S_SQ_branch2>0))
:      39 
: ---> 40 ax[0].set_xlim((0.5,2))
:      41 ax[0].set_ylim((0.5,2))
: 
: AttributeError: 'numpy.ndarray' object has no attribute 'set_xlim'
[[file:./.ob-jupyter/afee4262b1ba34dff96535c34acdb3fbccdfa4e3.png]]
:END:


#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  Dgams = np.linspace(-2*np.pi,2*np.pi,1000)
  theta1s = np.linspace(0,4*np.pi,1000)
  eps = np.logspace(-1, 1, 10)
  THETA1S, DGAMS = np.meshgrid(theta1s, Dgams) 
  
  alpha0 = (2./3)**(2./3)
  f1 = -A(alpha0, 2)
  f2 = -B(alpha0, 2)
  def thetahat(theta1, ep, Dgam):
      return(
          np.arctan2(
              f1*sin(theta1) + ep*f2*sin(theta1-Dgam),
              f1*cos(theta1) + ep*f2*cos(theta1-Dgam)) % (2*np.pi)
      )
  fig, ax = plt.subplots(2,5,figsize=(20,8))
  for i, ep in enumerate(eps):
      j = 0
      if i > 4:
          i = i % 5
          j = 1
      cs = ax[j][i].pcolormesh(THETA1S, DGAMS, cos(thetahat(THETA1S, ep, DGAMS)),cmap="bwr")
      #cbar = plt.colorbar(cs, ax=ax)
      ax[j][i].set_title(r"$e_1/e_2=$"+f"{ep:0.2f}")
      ax[j][i].set_xlabel(r"$\theta_1$")
      ax[j][i].set_ylabel(r"$\Delta\gamma$")
#+END_SRC

#+RESULTS:
:RESULTS:
: <ipython-input-43-cdc9f4cd640e>:21: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.
:   cs = ax[j][i].pcolormesh(THETA1S, DGAMS, cos(thetahat(THETA1S, ep, DGAMS)),cmap="bwr")
[[file:./.ob-jupyter/9fcaf9da6dbc7f69ba051007d96be8e881c08316.png]]
:END:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  class sqr_e2_TeTm:
      def __init__(self, j, Te, Tm, f1, f2):
          # Tm is effective migration rate
          # Te = Te1 = Te2
          self.j = j
          self.Te = Te
          self.Tm = Tm
          self.f1 = f1
          self.f2 = f2
          self.alpha_0 = (j/(j+1))**(2./3)
      def __call__(self, q):
          sqr_e2 = (0.5*self.Te/self.Tm/(1 -
                     self.j*(q/self.alpha_0+1)
                     /q/sqrt(self.alpha_0)
                     + (1-self.j*(q/self.alpha_0+1))
                     ,*self.f2**2/self.f1**2/self.alpha_0/q**2
                    ))
          return(sqr_e2)
  j = 2
  alpha_0 = (j/(j+1))**(2./3)
  f1 = -A(alpha_0, j)
  f2 = -B(alpha_0, j)
  sqr_e2_func = sqr_e2_TeTm(j, 1e3, 1e5,  f1, f2)
  qs = np.logspace(-1, 1, 1000)
  plt.plot(qs, sqr_e2_func(qs))
#+END_SRC

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7f54c05ebee0> |
[[file:./.ob-jupyter/a6d58e5d2559a1e1277fb41b6142cf90b0ea4a9d.png]]
:END:

* gamma hat
** regular
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/standard-compmass/")
  readme = "totmass q Te1 Te2 e1 e2 |g1-g2| \n " \
      "averages taken from 0.9xT; T = 20.xTe0; Te0=1000"
  #################
  # CONFIGURATION #
  #################
  j = 2
  a0 = 1.0
  alpha_0 = (j/(j+1))**(2./3.)
  #Nqs = 25
  #qs = np.logspace(-2, 2, Nqs)
  #Nqs = 10
  #qs = np.linspace(0.5,2,Nqs)
  qs = np.array([0.5, 0.75, 0.9, 1.1,1.5, 2.])
  Nqs = len(qs)
  overwrite = True
  totmass = 1e-3
  e0 = 0.001
  
  ######################
  # Varying parameters #
  ######################
  Tw0 = 1000.
  TeRatios = np.sqrt(qs)
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*0.1
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = np.array(qs)
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  ALPHA_0 = alpha_0*np.ones(Nqs)
  TE1 = Tw0*TeRatios
  TE2 = Tw0/TeRatios
  #TM1 = np.infty*np.ones(Nqs)
  TM1 = TE1/3.46/HS**2*(1*(qs<1) - 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(1*(qs<1) - 1*(qs>=1))
  TS = 40.*np.maximum(TE1, TE2)
  print(TS)
  #E1_0 = np.minimum(0.1/sqrt(QS), 0.1*np.ones(Nqs))
  #E2_0 = np.minimum(0.1*sqrt(QS), 0.1*np.ones(Nqs))
  E1_0 = np.ones(Nqs)*e0
  E2_0 = np.ones(Nqs)*e0
  print(E1_0,E2_0)
  E1DS = np.zeros(Nqs)
  E2DS = np.zeros(Nqs)
  CUTOFFS = TS
  #ALPHA2_0 = (3/2.)**(2./3)*(1+E2_0**2+E1_0**2)
  ALPHA2_0 = (1.7)**(2./3)*np.ones(Nqs)
  
  NAMES = np.array([f"q{QS[i]:0.2f}" for i in range(Nqs)])
  
  DIRNAMES = np.array([f"standard-h-{HS[i]:0.2f}-Tw0-{int(Tw0)}"
                       for i in range(len(QS))])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"-nosec" for i in range(Nqs)])
  
  i = -1
  name = NAMES[i]
  print(name)
  data = np.load(os.path.join(DIRNAMES[i], name+".npz"))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
#+END_SRC

#+RESULTS:
: [56568.54249492 46188.02153517 42163.70213558 41952.35392681
:  48989.79485566 56568.54249492]
: [0.001 0.001 0.001 0.001 0.001 0.001] [0.001 0.001 0.001 0.001 0.001 0.001]
: q2.00

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fontsize=24
  fig, ax = plt.subplots(2, figsize=(6,12))
  tscale = 1.
  
  
  iplt0 = np.where(teval > 1e2)[0][0]
  teval = teval[iplt0:]
  
  iplt = np.where(teval > 1e4)[0][0]
  
  hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hatg1 = np.arctan2(e1*sin(g1) + f2/f1*e2*sin(g2),
                        e1*cos(g1) + f2/f1*e2*cos(g2))
  
  filter_size = 1
  plt_skip = 1
  hatg1_sm = sp.ndimage.uniform_filter1d(hatg1, filter_size)
  hattheta1s_sm = sp.ndimage.uniform_filter1d(hattheta1s, filter_size)
  
  ax[0].scatter(teval[:iplt:plt_skip]/tscale, hatg1_sm[:iplt:plt_skip], s=2, alpha=0.8, c="k")
  ax[1].scatter(teval[:iplt:plt_skip]/tscale, g1[:iplt:plt_skip], s=2, alpha=0.8, c="k")
#+END_SRC

#+RESULTS:
:RESULTS:
: <matplotlib.collections.PathCollection at 0x7fe4c543b070>
[[file:./.ob-jupyter/deb4b5c18069d0bfd585c652ac8f61fe1ce7d601.png]]
:END:

** driven
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/Dropbox/multi-planet-architecture/runs/compmass-Rhat/")
  #################
  # CONFIGURATION #
  #################
  j = 2
  a0 = 1.0
  h = 0.1
  alpha_0 = (j/(j+1))**(2./3.)
  Nqs = 1
  qs = np.ones(Nqs)*2
  overwrite = True
  totmass = 1e-3
  Tw0 = 1000
  TeRatios = sqrt(qs)
  
  ######################
  # Varying parameters #
  ######################
  E1_0 = np.ones(Nqs)*0.001
  E2_0 = np.ones(Nqs)*0.001
  E1DS = np.ones(Nqs)*0.3
  E2DS = np.ones(Nqs)*0.0
  
  
  #eccs = np.array([0.1])
  #E1_0, E2_0 = np.meshgrid(eccs, eccs)
  #E1_0 = np.flip(E1_0.flatten())
  #E2_0 = np.flip(E2_0.flatten())
  
  ####################
  # THREADING ARRAYS #
  ####################
  HS = np.ones(Nqs)*h
  JS = np.ones(Nqs)*j
  A0S = np.ones(Nqs)*a0
  QS = qs
  MU2 = totmass/(1+QS)
  MU1 = totmass - MU2
  
  TE1 = Tw0*TeRatios
  TE2 = Tw0/TeRatios
  TM1 = TE1/3.46/HS**2*(1*(qs<1) - 1*(qs>=1))
  TM2 = TE2/3.46/HS**2*(1*(qs<1) - 1*(qs>=1))
  TS = 15.*np.maximum(TE1, TE2)
  ALPHA_0 = alpha_0*np.ones(Nqs)
  #############################################################
  # BUG: SETTING CUTOFF TO T RESULTS IN DIFFERENCES BETWEEN T #
  # VALUES. LIKELY A FACTOR OF 2PI THING.                     #
  #############################################################
  cutoff_frac = 1.0
  CUTOFFS = TS*cutoff_frac
  ALPHA2_0 = (3/2.)**(2./3)*1.
  NAMES = np.array([f"e1d-{E1DS[i]:0.3f}-e2d-{E2DS[i]:0.3f}"
                    for i, qit in enumerate(QS)])
  
  DIRNAMES = np.array([f"./driveTe-h-{h:0.2f}-Tw0-{Tw0}" for i
                          in range(Nqs)])
  DIRNAMES_NOSEC = np.array([DIRNAMES[i]+"_NOSEC" for i in range(Nqs)])
  
  i = 0
  dirname = DIRNAMES[i]
  name = NAMES[i]+".npz"
  print(name)
  data = np.load(os.path.join(dirname, name))
  teval  = data["teval"]
  theta  = data["thetap"]
  a1     = data["a1"]
  a2     = data["a2"]
  e1     = data["e1"]
  e2     = data["e2"]
  g1     = data["g1"]
  g2     = data["g2"]
  L1     = data["L1"]
  L2     = data["L2"]
  x1     = data["x1"]
  y1     = data["y1"]
  x2     = data["x2"]
  y2     = data["y2"]
 #+END_SRC 

 #+RESULTS:
 : e1d-0.300-e2d-0.000.npz
 
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  fontsize=24
  fig, ax = plt.subplots(2, figsize=(6,12))
  tscale = 1.
  
  
  iplt0 = np.where(teval > 1e2)[0][0]
  teval = teval[iplt0:]
  
  iplt = np.where(teval > 1e4)[0][0]
  
  hattheta1s = np.arctan2(e1*sin(theta1) + f2/f1*e2*sin(theta2),
                        e1*cos(theta1) + f2/f1*e2*cos(theta2))
  hatg1 = np.arctan2(e1*sin(g1) + f2/f1*e2*sin(g2),
                        e1*cos(g1) + f2/f1*e2*cos(g2))
  
  filter_size = 1
  plt_skip = 1
  hatg1_sm = sp.ndimage.uniform_filter1d(hatg1, filter_size)
  hattheta1s_sm = sp.ndimage.uniform_filter1d(hattheta1s, filter_size)
  
  ax[0].scatter(teval[:iplt:plt_skip]/tscale, hatg1_sm[:iplt:plt_skip], s=2, alpha=0.8, c="k")
  ax[1].scatter(teval[:iplt:plt_skip]/tscale, g1[:iplt:plt_skip], s=2, alpha=0.8, c="k")
#+END_SRC

#+RESULTS:
:RESULTS:
: <matplotlib.collections.PathCollection at 0x7fe4c5506790>
[[file:./.ob-jupyter/1590be8583b1a086417385a73acc90e4817931de.png]]
:END:

* OLD
** eccentricity excitement, Te1d & Te2d 
*Question:* What value does Te2 take for equilibrium if e2 -> e2d is
fixed as a parameter?
- should try this with an eccentricity driving force of $\dot e =
  -(e-e_d)/T_{e2d}$ but how does $dT_{e,2}/d\tau$ play into this?
- I think this code leaves out derivatives of Te2 and so maybe it
  can't be trusted
- Hacked together a very basic $T_1(e_1)$, $T_2(e_2)$, seems to shift both
  equilibrium values lower, however?
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  import os
  from numpy import sqrt, cos, sin, pi, abs
  import scipy as sp
  import scipy.optimize
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  import sys
  sys.path.append("/home/jtlaune/multi-planet-architecture/")
  from helper import *
  import importlib
  import os
  plt.rcParams.update({"font.size": 20, "figure.facecolor": "white", "figure.figsize": (10,10)})
  
  class solve_eqeccs:
      def __init__(self, q, totmass, j, Tm1, Tm2, Te1d, Te2d, e1d, e2d, secterms=True):
          # this class returns the equilibrium equations divided by mu2
          self.q = q
          self.mu2 = totmass/(1+q)
          alpha_0 = (j/(j+1))**(2./3.)
          self.alpha_0 = alpha_0
          self.alpha_2 = 1./alpha_0
          self.f1 = -A(alpha_0, j)
          self.f2 = -B(alpha_0, j)
          if secterms:
              self.C = C(alpha_0)
              self.D = D(alpha_0)
          else:
              self.C = 0.
              self.D = 0.
          self.Tm1 = Tm1
          self.Tm2 = Tm2
  
          # driving force
          self.e1d = e1d
          self.Te1d = Te1d
          self.e2d = e2d
          self.Te2d = Te2d
      def Te1(self, e1):
          # returns the time rather than the derivative
          if abs(e1-self.e1d) < 1e-9:
              return(np.inf)
          else:
              return(self.Te1d/(e1-self.e1d)*e1)
      def Te2(self, e2):
          # returns the time rather than the derivative
          if abs(e2-self.e2d) < 1e-9:
              return(np.inf)
          else:
              return(self.Te2d/(e2-self.e2d)*e2)
      def dote1(self, e1, e2, theta1, theta2):
          deriv = -self.mu2/self.alpha_2*(self.f1*sin(theta1) + self.D*e2*sin(theta1-theta2)) - e1/self.Te1(e1)
          return(deriv)
      def dote2(self, e1, e2, theta1, theta2):
          deriv = -self.mu2/self.alpha_2*self.q*(self.f2*sin(theta2) + self.D*e1*sin(theta2-theta1)) - e2/self.Te2(e2)
          return(deriv)
      def dotdpom(self, e1, e2, theta1, theta2):
          #deriv = self.mu2/self.alpha_2*(self.f1*cos(theta1)/(e1*sqrt(self.alpha_0))
          #         - self.q*cos(theta2)/e2
          #         + 2*self.C/sqrt(self.alpha_0)
          #         + self.D*e2/e1/sqrt(self.alpha_0)
          #         -self.q*2*self.C/sqrt(self.alpha_2)
          #         - self.q*self.D*e1/e2/sqrt(self.alpha_2))
          deriv = (self.f1*e2*cos(theta1)/(sqrt(self.alpha_0))
                   - self.q*self.f2*cos(theta2)*e1
                   + 2*self.C/sqrt(self.alpha_0)*e1*e2
                   + self.D*e2**2/sqrt(self.alpha_0)
                   -self.q*2*self.C/sqrt(self.alpha_2)*e1*e2
                   - self.q*self.D*e1**2/sqrt(self.alpha_2))
          return(deriv)
      def doteta(self, e1, e2, theta1, theta2):
          deriv = (self.q*sqrt(self.alpha_0)/(j*(self.q/self.alpha_0 +
                                                 1)) *(1./self.Tm2 -
                                                       1./self.Tm1 +
                                                       2*e1**2/self.Te1(e1) -
                                                       2*e2**2/self.Te2(e2)) -
                   self.q*sqrt(self.alpha_0)*2*e1**2/self.Te1(e1)
                   - 2*e2**2/self.Te2(e2))
          return(deriv)
      def __call__(self, vec):
          (e1, e2, theta1, theta2) = vec[:]
          e1_deriv = self.dote1(e1, e2, theta1, theta2)
          e2_deriv = self.dote2(e1, e2, theta1, theta2)
          dpom_deriv = self.dotdpom(e1, e2, theta1, theta2)
          eta_deriv =  self.doteta(e1, e2, theta1, theta2)
          deriv_arr = np.array([e1_deriv,
                                e2_deriv,
                                dpom_deriv,
                                eta_deriv])
          #print(vec, deriv_arr)
          return(deriv_arr)
  
  def get_eeqs(dir):
      NQS = 36
      QS = np.logspace(-3.,0.,NQS)
      NAMES = np.array([f"q{qit:0.2f}" for qit in QS])
      FILENAMES   = [os.path.join(dir, f"{name}.npz") for name in NAMES]
      qscatters = -1*np.ones(NQS)
      e1eqs = np.zeros(NQS)
      e2eqs = np.zeros(NQS)
      dpoms = np.zeros(NQS)
      for fi, filename in enumerate(FILENAMES):
          if os.path.exists(filename):
              data = np.load( filename)
              teval = data["teval"]
              theta = data["thetap"]
              e1    = data["e1"]
              e2    = data["e2"]
              g1    = data["g1"]
              g2    = data["g2"]
  
              it = int(0.9*len(teval))
              e1eqs[fi] = np.average(e1[it:])
              e2eqs[fi] = np.average(e2[it:])
              dpoms[fi] = np.average(np.abs(e2[it:]-e1[it:]))
              qscatters[fi] = QS[fi]
      return(e1eqs, e2eqs, dpoms, qscatters)
  
  
  def calc_eeqs(h, Nqs, qs, j, alpha_0, totmass, Tm1s, Tm2s, Te1ds, Te2ds, e1d, e2d, secterms=True):
      e1s = np.zeros(Nqs)
      e2s = np.zeros(Nqs)
      theta1s = np.zeros(Nqs)
      theta2s = np.zeros(Nqs)
  
      for iq, q in enumerate(qs):
          Te1d = 2*pi*Te1ds[iq]
          Te2d = 2*pi*Te2ds[iq]
          Tm1 = 2*pi*Tm1s[iq]
          Tm2 = 2*pi*Tm2s[iq]
          #if q <= 1:
          #    Te2d = TW0*2*np.pi
          #    Te1d = Te2d/q/alpha_0**0.5
  
          #    Tm1 = Te1d/2.7/h**2
          #    Tm2 = Te2d/2.7/h**2
          #else:
          #    Te1d = TW0*2*np.pi
          #    Te2d = Te1d*q*alpha_0**0.5
  
          #    Tm1 = Te2d/2.7/h**2
          #    Tm2 = Te1d/2.7/h**2
  
          x0 = (h/sqrt(q), h*sqrt(q), pi, 0.)
          mfunc = solve_eqeccs(q, totmass, j, Tm1, Tm2, Te1d, Te2d, e1d, e2d, secterms=secterms)
          sol = scipy.optimize.root(mfunc, x0, options={"maxfev":int(1e4)})
          x = sol.x
          #if not sol.success:
          #    print(sol.message)
          e1 = x[0]
          e2 = x[1]
          theta1 = x[2]
          theta2 = x[3]
          e1s[iq] = e1
          e2s[iq] = e2
          theta1s[iq] = theta1
          theta2s[iq] = theta2
          #print(x, mesg, infodict["nfev"])
          #print(theta1-theta2)
      return(e1s, e2s, theta1s, theta2s)
 #+END_SRC

 #+RESULTS:

#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  os.chdir("/home/jtlaune/multi-planet-architecture/runs/compmass-eq/qles1/")
  h = 0.025
  Nqs = 1000
  qs = np.logspace(np.log10(1.5), 2., Nqs)
  #qs = [0.01]
  j = 2
  alpha_0 = (j/(j+1))**(2./3.)
  e1d = 0.2
  e2d = 0.2
  
  totmass = 1e-3
  Nqs = 1000
  qs = 3.*np.ones(Nqs)
  Tw0 = 1e4
  Te1ds = Tw0*np.ones(Nqs)
  Te2ds = np.logspace(np.log10(Tw0)-2, np.log10(Tw0)+2, Nqs)
  Tm1s = 1e6*np.ones(Nqs)
  Tm2s = Tm1s/10.
  
  e1s, e2s, theta1s, theta2s = calc_eeqs(h, Nqs, qs, j, alpha_0,
                                         totmass, Tm1s, Tm2s, Te1ds, Te2ds,
                                         e1d, e2d, secterms=True)
  #(e1s_e2d0, e2s_e2d0,
  # theta1s_e2d0, theta2s_e2d0) = calc_eeqs(h, Nqs, qs, j, alpha_0,
  #                                           totmass, 0., 0., secterms=True)
  #(e1s_nosec, e2s_nosec,
  # theta1s_nosec, theta2s_nosec) = calc_eeqs(h, Nqs, qs, j, alpha_0,
  #                                           totmass, e1d, e2d, secterms=False)
  
  fig, ax = plt.subplots(2)
  #ax[0].plot(qs, e1s, ls="--", c="blue"  ,   label=(r"$e_1$"))
  #ax[0].plot(qs, e2s, ls="--", c="orange", label=(r"$e_2$"))
  ax[0].plot(Te2ds/Te1ds, e1s,   label=(r"$e_1$"))
  ax[0].plot(Te2ds/Te1ds, e2s, label=(r"$e_2$"))
  ax[1].plot(qs, theta1s)
  ax[1].plot(qs, theta2s)
  ax[0].set_xscale("log")
  ax[0].set_yscale("log")
  ax[1].set_xscale("log")
  ax[1].set_yscale("log")
  ax[0].legend()
  ax[0].set_xlabel("q")
  #ax.set_ylim((0.,0.4))
  fig.suptitle(f"{j}:{j+1} MMR "+r"$h=$"+f"{h:0.1e} "+r"$\mu_{\rm tot}=$"+f"{totmass:0.1e}")
  fig.tight_layout()
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: FileNotFoundError                         Traceback (most recent call last)
: <ipython-input-4-ef6c77d93f2f> in <module>
: ----> 1 os.chdir("/home/jtlaune/multi-planet-architecture/runs/compmass-eq/qles1/")
:       2 h = 0.025
:       3 Nqs = 1000
:       4 qs = np.logspace(np.log10(1.5), 2., Nqs)
:       5 #qs = [0.01]
: 
: FileNotFoundError: [Errno 2] No such file or directory: '/home/jtlaune/multi-planet-architecture/runs/compmass-eq/qles1/'
:END:
