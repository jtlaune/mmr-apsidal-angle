#+TITLE: 1D Disk Cavity Simulator
* preamble
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  import numpy as np
  from numpy import pi, gradient, abs, sqrt, square, exp
  import matplotlib as mpl
  import matplotlib.pyplot as plt
  from astropy import constants as const 

  plt.rcParams.update({"font.size": 20,
                       "figure.facecolor": "white",
                       "figure.figsize": (6,6),
                       #'font.family': 'serif',
                       #"font.serif": ["DejaVu Serif"],
                       #"text.usetex": False,
                       "axes.linewidth": 3,
                       'font.family': 'lmodern',
                       'text.usetex': True,
                       'text.latex.preamble': (            # LaTeX preamble
                           r'\usepackage{lmodern}'
                           # ... more packages if needed
                       )
                       })
#+END_SRC

#+RESULTS:
* free parameters
** M
* unperturbed disk velocity profile
** Omega(r), B(r), kappa(r)
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def scaleby(scale):
      def divideby(func):
          def wrapper(_, *r):
              return(func(_, *r)/scale)
          return(wrapper)
      return(divideby)

  class DiskVelProfile: # Omega(r)
      scale = 1/square(2*pi) # [au^2]/[yrs^2]
      def __init__(self, sqr, dsqr, d2sqr, GM_2a0=None):
          self.sqr_func   = sqr
          self.dsqr_func  = dsqr
          self.d2sqr_func = d2sqr
          if GM_2a0 is not None:
              DiskVelProfile.scale   = GM_2a0

      @scaleby(scale)
      def sqr(self, r):
          return(self.sqr_func(r))

      @scaleby(scale)
      def dsqr(self, r):
          return(self.dsqr_func(r))

      @scaleby(scale)
      def d2sqr(self, r):
          return(self.d2sqr_func(r))

      @scaleby(sqrt(scale))
      def __call__(self, r):
          return(np.sqrt(self.sqr(r)))

      @scaleby(1.)
      def d(self, r):
          return(1/2/self(r)*self.dsqr(r))

      @scaleby(1.)
      def d2(self, r):
          return(1/2/self(r)*self.d2sqr(r)-1/2/self.sqr(r)*self.dsqr(r)*self.d(r))

      @scaleby(1.)
      def B(self, r): return(self(r) + r/2*self.d(r)) # Oort parameter

      @scaleby(1.)
      def dB_dr(self, r): return(self.d(r) + 0.5*self.d(r) + r/2*self.d2(r))

      @scaleby(1.)
      def kap2(self, r): return(4*self.B(r)*self(r))

      @scaleby(1.)
      def dkap2_dr(self, r): return(4*(self.dB_dr(r)*self(r)+self.B(r)*self.d(r)))

      @scaleby(1.)
      def D(self, r, m, om):
          return(self.kap2(r) - (m*self(r) - om)**2)

      @scaleby(1.)
      def dD_dr_om(self, r, m, om):
          return(self.dkap2_dr(r) - 2*(m*self(r)-om)*m*self.d(r))

  def sqr(r): return(r**(-3))
  def dsqr(r): return(-3*r**(-4))
  def d2sqr(r): return(12*r**(-5))
  Kep = DiskVelProfile(sqr, dsqr, d2sqr)
  Kep.dD_dr_om(1., 5., 1.)
#+END_SRC

#+RESULTS:
: 2654.293188294127
* unperturbed disk density profile
** sigma(r)
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def scaleby(scale):
      def divideby(func):
          def wrapper(_, *r):
              return(func(_, *r)*scale)
          return(wrapper)
      return(divideby)
  class DiskSurfDensProfile:
      scale_time = 1./3.154e7 # 1 s in yr
      scale_mass = 1./const.M_earth.cgs.value # 1 g in M_earth
      scale_length = 1./const.au.cgs.value # 1cm in au

      scale_sigma = 1./(scale_mass/scale_length**2) # 1 g/cm^2 in M_earth/au^2
      scale_c2 = 1./(scale_length**2/scale_time**2)

      scale_gravConst = 1./(2*pi*const.G.cgs.value)
      scale_pressure = scale_gravConst/(scale_length*scale_mass/scale_time**2)

      def __init__(self, func, gam, scales=None):
          self.func = func
          self.g = gam
          self.K = 1./(self.scale_pressure/self.scale_sigma**self.g)
          if scales is not None:
              # Msun_au2 [g/cm^2]
              DiskProfile.scale_mass=1./scales[0]
              DiskProfile.scale_sigma=1./scales[1]
              DiskProfile.scale_length=1./scales[2]
              DiskProfile.scale_time=1./scales[3]
              self.rescale()

      def rescale(self):
          mass_units = DiskProfile.scale_mass
          density_units = DiskProfile.scale_sigma
          length_units = DiskProfile.scale_length
          time_units = DiskProfile.scale_time

          DiskProfile.scale_pressure = 1./(mass_units/time_units**2)
          DiskProfile.scale_c2 = 1./(length_units/time_units)**2

      @scaleby(scale_sigma)
      def __call__(self, r): # g/cm^2
          return(self.func(r))

      @scaleby(scale_pressure)
      def p(self, r): # int g/cm/s^2 d(cm) = 2*pi*r0*m0/t0^2
          return(self.K*pow(self(r), self.g))

      @scaleby(scale_c2)
      def c2(self, r): # cm^2/s^2
          return(self.g*self.K*pow(self(r), self.g-1.))

      @scaleby(sqrt(scale_c2))
      def c(self, r): # cm/s
          return(sqrt(self.c2(r)))

      @scaleby(scale_mass*scale_c2)
      def eta(self, r): # g cm^2/s^2
          return(self.c2(r)/(self.g-1))

      @scaleby(scale_gravConst*scale_sigma*scale_length/scale_c2)
      def alpha(self, r, k):
          return(1.*self(r)*r/self.c2(r)*np.sign(k))
  
  func = lambda x: 1/x**(1.5)
  Cav = DiskSurfDensProfile(func, 1.5)
  Cav.alpha(1., 1.)
#+END_SRC

#+RESULTS:
: 449.6672861337363

* perturbation parameters
** planet perturbation frequency and handy functions
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def scaleby(scale):
      def divideby(func):
          def wrapper(_, r):
              return(func(_, r)*scale)
          return(wrapper)
      return(divideby)
  class PlanetPert:
      scale_mass = 1./const.M_earth.cgs.value
      scale_length = 1./const.au.cgs.value
      scale_time = 1./3.154e7 # 1 s in yr
      def __init__(self, mp, ap, ep=0.):
          PlanetPert.scale_mass = PlanetPert.scale_mass/mp
          PlanetPert.scale_length = PlanetPert.scale_length/ap
          self.mp = mp # mass in Mearth
          self.ap = ap # sma in au
          self.om = self.ap**1.5/(2*pi)
          self.ep = ep
          if not ep == 0.:
              raise Warning("Cannot do finite ep yet")

      @scaleby(scale_mass/scale_length)
      def phi1(self, rL):
          """
          insert planet potential with parameters mp and ap
          """
          return(
              -self.mp/rL
          )

      @scaleby(scale_mass/scale_length**2)
      def dphi1_dr(self, rL):
          return(
              -self.mp/rL**2
              )
  Pl = PlanetPert(1., 1.)
  print(Pl.phi1(1.))
  print(Pl.dphi1_dr(1.))
#+END_SRC

#+RESULTS:
: -2.5049173769344184e-15
: -0.037473030586881825

* AM integration
** F(sigma, r, phi1, m, rL)
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  def F(r, m, rL, planet, sigma, Omega): # total AM flux for LBR torques
      return(-m*pi**2*( abs(sigma(r)/(rL*Omega.dD_dr_om(rL,m,planet.om)))
                        ,*square(rL*planet.dphi1_dr(rL) +
                                (2*m*Omega(rL))/(m*Omega(rL)-planet.om)*planet.phi1(rL)
                                )
                       )
             )
#+END_SRC

#+RESULTS:

** summation
#+BEGIN_SRC jupyter-python :session /jpy:localhost#8888:research
  # m azimuthal mode number
  r = np.logspace(-1., np.log10(3), 1000)
  m = np.arange(100) # azimuthal wave numbers
  RR, MM = np.meshgrid(r, m)
  ap = 0.7 # au
  mp = 17.0 # M earth
  gam = 1.5

  Pl = PlanetPert(mp, ap)

  func = lambda x: 1./(1+exp(5.*(1.-x)/0.1))
  Cav = DiskSurfDensProfile(func, gam)

  def sqr(r): return(r**(-3))
  def dsqr(r): return(-3*r**(-4))
  def d2sqr(r): return(12*r**(-5))
  Kep = DiskVelProfile(sqr, dsqr, d2sqr)

  ####################################################
  #  Figures
  ####################################################
  fig, ax = plt.subplots(1,3,figsize=(12,4))

  ####################################################
  # Plots (first 2 columns)
  ####################################################
  rL = (2)**(2./3.) # 2:1 lindblad resonance
  RLmesh = rL*RR

  F_marr = F(RR, MM, RLmesh, Pl, Cav, Kep)
  F_sum = np.sum(F_marr, axis=0)


  ####################################################
  # Plots (third column)
  ####################################################
  G_marr = F(RLmesh, MM, RR, Pl, Cav, Kep)/Pl.mp
  G_sum = np.sum(G_marr, axis=0)
  for jit in range(2,8):
      rL = ((jit+1)/jit)**(2./3.) # 2:1 lindblad resonance
      RLmesh = rL*RR
      G_marr = F(RLmesh, MM, RR, Pl, Cav, Kep)/Pl.mp
      G_sum = G_sum + np.sum(G_marr, axis=0)

  ####################################################
  # Plots (fourth column)
  ####################################################
  #H_marr = (Pl.mp*Pl.ap*Kep(Pl.ap))/(2*pi*Pl.mp*F(RLmesh, MM, RR, Pl, Cav, Kep)/Pl.mp) # time
  #H_sum = np.sum(H_marr, axis=0)
  #for jit in range(2,8):
  #    rL = ((jit+1)/jit)**(2./3.) # 2:1 lindblad resonance
  #    RLmesh = rL*RR
  #    H_marr = F(RLmesh, MM, RR, Pl, Cav, Kep)/Pl.mp
  #    H_sum = H_sum + np.sum(H_marr, axis=0)

  ####################################################
  # Columns
  ####################################################
  for axis in [ax[1]]:
      axis.set_title(r"$$\sum_{m} F(r_L)$$", pad=20)
      axis.plot(r, F_sum)
      axis.set_ylim((0,-15))
      for jit in range(1,6):
          axis.axvline(x=ap/(jit/(jit+1))**(2./3), ls="--", c="k")
      axis.axvline(x=ap, ls="--", c="r")
      axis.set_xlabel(r"$r_L$")
  for axis in [ax[0]]:
      axis.set_title(r"$\sigma_0$ [g/cm$^2$]", pad=20)
      axis.plot(r, Cav(r))
      axis.set_ylim((0,30))
      for jit in range(1,6):
          axis.axvline(x=ap/(jit/(jit+1))**(2./3), ls="--", c="k")
      axis.axvline(x=ap, ls="--", c="r")
      axis.set_xlabel(r"$r_L$")
  for axis in [ax[2]]:
      axis.set_title(r"$$\frac{1}{2\pi a_p m_p}\sum_{m,j} F(a_p; r_L) dr$$", pad=40)
      axis.plot(r, G_sum)
      axis.set_ylim((0,-5))
      axis.set_xlabel(r"$a_p$")
  #for axis in [ax[3]]:
  #    axis.set_title(r"OLR AMF/$m_p$")
  #    axis.plot(r, G_sum)
  #    axis.set_ylim((0,-5))
  #    axis.set_xlabel(r"$a_p$")

  ####################################################
  # Rows
  ####################################################
  for axis in ax:
      axis.set_xscale("linear")
      axis.set_yscale("linear")
      axis.set_xlim((0.5,1.5))

  fig.subplots_adjust(hspace=1., wspace=0.3)
#+END_SRC

#+RESULTS:
[[file:./.ob-jupyter/1c77f831fe6565b14ac7d5e77c5df999b915d3ea.png]]

